// CrecheBooks Prisma Schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
}

// ============================================
// ENUMS
// ============================================

enum TaxStatus {
  VAT_REGISTERED
  NOT_REGISTERED
}

enum SubscriptionStatus {
  TRIAL
  ACTIVE
  SUSPENDED
  CANCELLED
}

enum SubscriptionPlan {
  FREE
  STARTER
  PROFESSIONAL
  ENTERPRISE
}

enum UserRole {
  SUPER_ADMIN // CrecheBooks platform administrator (no tenant)
  OWNER // Creche/tenant owner
  ADMIN // Tenant administrator
  VIEWER // Read-only tenant user
  ACCOUNTANT // Tenant accountant
}

enum AuditAction {
  CREATE
  UPDATE
  DELETE
  DELETE_BLOCKED
  CATEGORIZE
  MATCH
  RECONCILE
  SUBMIT
  TRIAL_SIGNUP
  IMPERSONATION_START
  IMPERSONATION_END
}

enum ImportSource {
  BANK_FEED
  CSV_IMPORT
  PDF_IMPORT
  MANUAL
}

enum TransactionStatus {
  PENDING
  CATEGORIZED
  REVIEW_REQUIRED
  SYNCED
}

enum VatType {
  STANDARD
  ZERO_RATED
  EXEMPT
  NO_VAT
}

enum CategorizationSource {
  AI_AUTO
  AI_SUGGESTED
  USER_OVERRIDE
  RULE_BASED
}

enum Gender {
  MALE
  FEMALE
  OTHER
}

enum PreferredContact {
  EMAIL
  WHATSAPP
  BOTH
}

enum FeeType {
  FULL_DAY
  HALF_DAY
  HOURLY
  CUSTOM
}

enum EnrollmentStatus {
  ACTIVE
  PENDING
  WITHDRAWN
  GRADUATED
}

enum InvoiceStatus {
  DRAFT
  SENT
  VIEWED
  PARTIALLY_PAID
  PAID
  OVERDUE
  VOID
}

enum DeliveryMethod {
  EMAIL
  WHATSAPP
  BOTH
}

enum DeliveryStatus {
  PENDING
  SENT
  DELIVERED
  OPENED
  CLICKED
  BOUNCED
  COMPLAINED
  FAILED
}

enum LineType {
  // VAT EXEMPT - Educational/Childcare Services (Section 12(h))
  MONTHLY_FEE
  REGISTRATION
  RE_REGISTRATION // TASK-BILL-038: New - Continuing student annual fee
  EXTRA_MURAL // TASK-BILL-038: New - Subordinate to education
  EXTRA // Deprecated - Use specific types

  // VAT APPLICABLE - Goods & Non-Educational Services (15%)
  BOOKS
  SCHOOL_TRIP
  STATIONERY
  UNIFORM
  MEALS // TASK-BILL-038: New - Prepared food
  TRANSPORT // TASK-BILL-038: New - To/from school
  LATE_PICKUP // TASK-BILL-038: New - Penalty fee
  DAMAGED_EQUIPMENT // TASK-BILL-038: New - Replacement charge
  AD_HOC // Configurable via isVatExempt flag

  // NO VAT - Adjustments
  DISCOUNT
  CREDIT
}

enum MatchType {
  EXACT
  PARTIAL
  MANUAL
  OVERPAYMENT
}

enum MatchedBy {
  AI_AUTO
  USER
}

enum EmploymentType {
  PERMANENT
  CONTRACT
  PART_TIME
  CASUAL
}

enum PayFrequency {
  MONTHLY
  FORTNIGHTLY
  WEEKLY
  DAILY
  HOURLY
}

enum PayrollStatus {
  DRAFT
  APPROVED
  PAID
}

enum SubmissionType {
  VAT201
  EMP201
  IRP5
}

// TASK-SARS-005: Enhanced submission status tracking
// Status flow: DRAFT -> READY -> SUBMITTED -> ACCEPTED/REJECTED
// If REJECTED, can retry: REJECTED -> SUBMITTED -> ACCEPTED/REJECTED
enum SubmissionStatus {
  DRAFT
  READY
  SUBMITTED
  ACCEPTED
  REJECTED
  ACKNOWLEDGED // Legacy status, kept for backward compatibility (maps to ACCEPTED)
}

enum ReconciliationStatus {
  IN_PROGRESS
  RECONCILED
  DISCREPANCY
}

// TASK-RECON-019: Bank Statement Transaction Matching
enum BankStatementMatchStatus {
  MATCHED // Transaction exists in both bank and Xero
  IN_BANK_ONLY // Transaction in bank statement, not in Xero
  IN_XERO_ONLY // Transaction in Xero, not in bank statement
  AMOUNT_MISMATCH // Same transaction, different amounts
  DATE_MISMATCH // Same transaction, dates differ > 1 day
  FEE_ADJUSTED_MATCH // Match when Bank NET + Accrued Fee = Xero GROSS
}

// ============================================
// TASK-RECON-036: Accrued Bank Charges
// Tracks bank fees shown on statements but charged in following period
// ============================================

enum AccruedBankChargeStatus {
  ACCRUED // Fee shown on statement but not yet charged
  MATCHED // Fee matched to actual charge transaction
  REVERSED // Fee was reversed/waived
  WRITTEN_OFF // Fee written off (not expected to be charged)
}

// TASK-RECON-035: Split Transaction Matching
enum SplitMatchStatus {
  PENDING // Split match suggested, awaiting confirmation
  CONFIRMED // Split match confirmed and applied
  REJECTED // Split match rejected by user
}

// TASK-RECON-035: Split Match Types
enum SplitMatchType {
  ONE_TO_MANY // Single bank transaction matches multiple invoices
  MANY_TO_ONE // Multiple payments match single invoice
}

// TASK-RECON-037: Xero Transaction Split Status
enum XeroTransactionSplitStatus {
  PENDING // Split created but not confirmed
  CONFIRMED // Split confirmed and ready for matching
  MATCHED // Net amount matched to bank statement
  CANCELLED // Split cancelled/reverted
}

enum EscalationLevel {
  FRIENDLY
  FIRM
  FINAL
}

enum ReminderStatus {
  PENDING
  SENT
  DELIVERED
  READ
  FAILED
}

enum InvitationStatus {
  PENDING
  ACCEPTED
  EXPIRED
  REVOKED
}

// TASK-STAFF-001: Staff Onboarding Document Types
// DSD Compliance document categories for childcare workers
enum DocumentType {
  ID_DOCUMENT
  PROOF_OF_ADDRESS
  TAX_CERTIFICATE
  QUALIFICATIONS
  POLICE_CLEARANCE
  MEDICAL_CERTIFICATE
  FIRST_AID_CERTIFICATE
  EMPLOYMENT_CONTRACT
  BANK_CONFIRMATION
  POPIA_CONSENT
  SIGNED_CONTRACT
  SIGNED_POPIA
  OTHER
}

enum DocumentStatus {
  PENDING
  UPLOADED
  VERIFIED
  REJECTED
  EXPIRED
}

enum OnboardingStatus {
  NOT_STARTED
  IN_PROGRESS
  DOCUMENTS_PENDING
  VERIFICATION_PENDING
  COMPLETED
  CANCELLED
}

enum ChecklistItemStatus {
  NOT_STARTED
  IN_PROGRESS
  COMPLETED
  SKIPPED
  BLOCKED
}

// TASK-STAFF-002: Staff Offboarding Enums
enum OffboardingReason {
  RESIGNATION
  TERMINATION
  RETIREMENT
  DEATH
  CONTRACT_END
  MUTUAL_AGREEMENT
  RETRENCHMENT
  DISMISSAL
  ABSCONDED
}

enum StaffOffboardingStatus {
  INITIATED
  IN_PROGRESS
  PENDING_FINAL_PAY
  COMPLETED
  CANCELLED
}

enum AssetReturnStatus {
  NOT_APPLICABLE
  PENDING
  RETURNED
  NOT_RETURNED
  WRITE_OFF
}

// TASK-STAFF-006: UI-19 Deadline Tracking
enum UI19Type {
  COMMENCEMENT
  TERMINATION
}

enum UI19Status {
  PENDING
  SUBMITTED
  LATE_SUBMITTED
  OVERDUE
}

// TASK-ACCT-001: Chart of Accounts
enum AccountType {
  ASSET
  LIABILITY
  EQUITY
  REVENUE
  EXPENSE
}

enum AccountSubType {
  // Asset sub-types
  CURRENT_ASSET
  FIXED_ASSET
  OTHER_ASSET
  BANK
  // Liability sub-types
  CURRENT_LIABILITY
  LONG_TERM_LIABILITY
  // Equity sub-types
  OWNER_EQUITY
  RETAINED_EARNINGS
  // Revenue sub-types
  OPERATING_REVENUE
  OTHER_REVENUE
  // Expense sub-types
  COST_OF_SALES
  OPERATING_EXPENSE
  OTHER_EXPENSE
}

// TASK-ACCT-012: Quotes System
enum QuoteStatus {
  DRAFT
  SENT
  VIEWED
  ACCEPTED
  DECLINED
  EXPIRED
  CONVERTED
}

// TASK-ACCT-013: Supplier Management
enum BillStatus {
  DRAFT
  AWAITING_PAYMENT
  PARTIALLY_PAID
  PAID
  VOID
  OVERDUE
}

// TASK-ACCT-011: Payment Gateway
enum PaymentLinkStatus {
  ACTIVE
  EXPIRED
  USED
  CANCELLED
}

enum PaymentLinkType {
  INVOICE
  OUTSTANDING
  CUSTOM
  REGISTRATION
}

enum PaymentGatewayStatus {
  PENDING
  SUCCESSFUL
  FAILED
  REFUNDED
}

// TASK-ACCT-003: Opening Balances
enum OpeningBalanceImportStatus {
  DRAFT
  VALIDATING
  VALIDATED
  POSTING
  POSTED
  FAILED
}

// ============================================
// MODELS
// ============================================

model Tenant {
  id                      String             @id @default(uuid())
  name                    String             @db.VarChar(200)
  tradingName             String?            @map("trading_name") @db.VarChar(200)
  registrationNumber      String?            @map("registration_number") @db.VarChar(50)
  vatNumber               String?            @map("vat_number") @db.VarChar(20)
  taxStatus               TaxStatus          @default(NOT_REGISTERED) @map("tax_status")
  vatRegistrationDate     DateTime?          @map("vat_registration_date") @db.Date
  cumulativeTurnoverCents BigInt             @default(0) @map("cumulative_turnover_cents")
  addressLine1            String             @map("address_line1") @db.VarChar(200)
  addressLine2            String?            @map("address_line2") @db.VarChar(200)
  city                    String             @db.VarChar(100)
  province                String             @db.VarChar(50)
  postalCode              String             @map("postal_code") @db.VarChar(10)
  phone                   String             @db.VarChar(20)
  email                   String             @unique @db.VarChar(255)
  xeroTenantId            String?            @unique @map("xero_tenant_id") @db.VarChar(50)
  subscriptionStatus      SubscriptionStatus @default(TRIAL) @map("subscription_status")
  subscriptionPlan        SubscriptionPlan   @default(FREE) @map("subscription_plan")
  trialExpiresAt          DateTime?          @map("trial_expires_at")
  invoiceDayOfMonth       Int                @default(1) @map("invoice_day_of_month")
  invoiceDueDays          Int                @default(7) @map("invoice_due_days")
  closureDates            Json               @default("[]") @map("closure_dates")
  // TASK-RECON-002: Amount tolerance for transaction matching (in cents, default 0 = exact match)
  matchingToleranceCents  Int                @default(0) @map("matching_tolerance_cents")

  // TASK-BILL-043: Bank details for invoice/statement PDF generation
  bankName          String? @map("bank_name") @db.VarChar(100)
  bankAccountHolder String? @map("bank_account_holder") @db.VarChar(200)
  bankAccountNumber String? @map("bank_account_number") @db.VarChar(50)
  bankBranchCode    String? @map("bank_branch_code") @db.VarChar(20)
  bankAccountType   String? @map("bank_account_type") @db.VarChar(30)
  bankSwiftCode     String? @map("bank_swift_code") @db.VarChar(20)

  // TASK-ENROL-006: Parent welcome pack customization
  parentWelcomeMessage String? @map("parent_welcome_message") @db.Text
  operatingHours       String? @map("operating_hours") @db.VarChar(200)

  xeroConnectedAt DateTime? @map("xero_connected_at")
  xeroTenantName  String?   @map("xero_tenant_name") @db.VarChar(200)
  createdAt       DateTime  @default(now()) @map("created_at")
  updatedAt       DateTime  @updatedAt @map("updated_at")

  users                 User[]
  userTenantRoles       UserTenantRole[]
  invitations           Invitation[]
  transactions          Transaction[]
  payeePatterns         PayeePattern[]
  feeStructures         FeeStructure[]
  enrollments           Enrollment[]
  parents               Parent[]
  children              Child[]
  invoices              Invoice[]
  payments              Payment[]
  staff                 Staff[]
  payrolls              Payroll[]
  sarsSubmissions       SarsSubmission[]
  reconciliations       Reconciliation[]
  xeroToken             XeroToken?
  bankConnections       BankConnection[]
  reminders             Reminder[]
  categorizationMetrics CategorizationMetric[]
  xeroOAuthState        XeroOAuthState?
  invoiceDeliveryLogs   InvoiceDeliveryLog[]
  reminderTemplates     ReminderTemplate[]
  reminderConfig        ReminderConfig? // TASK-FEAT-102: Automated arrears config
  creditBalances        CreditBalance[]
  statements            Statement[]
  staffDocuments        StaffDocument[]
  staffOnboardings      StaffOnboarding[]
  xeroAccountMappings   XeroAccountMapping[]
  payrollJournals       PayrollJournal[]
  staffOffboardings     StaffOffboarding[]

  // TASK-STAFF-004: SimplePay Integration
  simplePayConnection       SimplePayConnection?
  simplePayEmployeeMappings SimplePayEmployeeMapping[]
  simplePayPayslipImports   SimplePayPayslipImport[]

  // TASK-SPAY-001: Leave Management
  leaveRequests LeaveRequest[]

  // TASK-SPAY-002: Pay Run Tracking
  payRunSyncs PayRunSync[]

  // TASK-SPAY-003: Calculations Management
  calculationItemCache CalculationItemCache[]
  payrollAdjustments   PayrollAdjustment[]

  // TASK-SPAY-004: Service Period Management
  servicePeriodSyncs ServicePeriodSync[]

  // TASK-SPAY-005: Report Requests
  reportRequests ReportRequest[]

  // TASK-SPAY-006: Profile Mapping Sync
  profileMappingSyncs ProfileMappingSync[]

  // TASK-SPAY-007: Bulk Operations
  bulkOperationLogs BulkOperationLog[]

  // TASK-SPAY-008: Employee Setup Pipeline
  employeeSetupLogs EmployeeSetupLog[]

  // TASK-XERO-006: Chart of Accounts Database Sync
  xeroAccounts XeroAccount[]

  // TASK-RECON-019: Bank Statement Transaction Matching
  bankStatementMatches BankStatementMatch[]

  // TASK-XERO-007: Categorization Journals for Reconciled Transactions
  categorizationJournals CategorizationJournal[]

  // TASK-BILL-041: Atomic Invoice Number Counters
  invoiceNumberCounters InvoiceNumberCounter[]

  // TASK-ACCT-011: Atomic Employee Number Counters
  employeeNumberCounters EmployeeNumberCounter[]

  // TASK-SARS-002: VAT201 Adjustment Fields
  vatAdjustments VatAdjustment[]

  // TASK-RECON-004: Duplicate Resolution tracking
  duplicateResolutions DuplicateResolution[]

  // TASK-RECON-005: Manual Match History tracking
  manualMatchHistory ManualMatchHistory[]

  // TASK-STAFF-006: UI-19 Deadline Tracking
  ui19Submissions UI19Submission[]

  // TASK-SPAY-009: SimplePay Webhook Handler
  webhookLogs WebhookLog[]

  // TASK-XERO-009: Bidirectional Invoice Sync
  xeroInvoiceMappings XeroInvoiceMapping[]

  // TASK-XERO-010: Xero Contact and Payment Sync
  xeroContactMappings XeroContactMapping[]
  xeroPaymentMappings XeroPaymentMapping[]

  // TASK-RECON-035: Split Transaction Matching
  splitMatches SplitMatch[]

  // TASK-RECON-036: Accrued Bank Charges
  accruedBankCharges AccruedBankCharge[]

  // TASK-RECON-037: Xero Transaction Splitting
  xeroTransactionSplits XeroTransactionSplit[]

  // TASK-REL-101: Circuit Breaker Pending Sync Queue
  pendingSyncs PendingSync[]

  // TASK-INT-101: Stitch Open Banking Integration
  linkedBankAccounts LinkedBankAccount[]

  // TASK-WA-001: WhatsApp Message History
  whatsAppMessages WhatsAppMessage[]

  // TASK-COMM-001: Ad-hoc Communication
  broadcastMessages BroadcastMessage[]
  recipientGroups   RecipientGroup[]

  // TASK-ADMIN-001: Impersonation Sessions (AWS SSO-style tenant switching)
  impersonationSessions ImpersonationSession[]

  // TASK-ACCT-001: Chart of Accounts
  chartOfAccounts ChartOfAccount[]

  // TASK-ACCT-003: Opening Balances
  openingBalances       OpeningBalance[]
  openingBalanceImports OpeningBalanceImport[]

  // TASK-ACCT-012: Quotes System
  quotes              Quote[]
  quoteNumberCounters QuoteNumberCounter[]

  // TASK-ACCT-013: Supplier Management
  suppliers            Supplier[]
  supplierBills        SupplierBill[]
  supplierBillPayments SupplierBillPayment[]

  // TASK-ACCT-011: Payment Gateway
  paymentLinks               PaymentLink[]
  paymentGatewayTransactions PaymentGatewayTransaction[]

  // TASK-ACCT-014: Onboarding Wizard
  onboardingProgress OnboardingProgress?

  @@map("tenants")
}

// ============================================
// TASK-ADMIN-001: AWS SSO-Style Tenant Switching
// Impersonation sessions for SUPER_ADMIN users to access tenant endpoints
// ============================================

model ImpersonationSession {
  id             String    @id @default(uuid())
  superAdminId   String    @map("super_admin_id")
  targetTenantId String    @map("target_tenant_id")
  assumedRole    UserRole  @map("assumed_role")
  startedAt      DateTime  @default(now()) @map("started_at")
  endedAt        DateTime? @map("ended_at")
  expiresAt      DateTime  @map("expires_at")
  ipAddress      String?   @map("ip_address") @db.VarChar(45)
  userAgent      String?   @map("user_agent")
  reason         String?   @db.Text
  isActive       Boolean   @default(true) @map("is_active")

  superAdmin   User   @relation("SuperAdminSessions", fields: [superAdminId], references: [id])
  targetTenant Tenant @relation(fields: [targetTenantId], references: [id])

  @@index([superAdminId, isActive])
  @@index([targetTenantId])
  @@index([expiresAt])
  @@map("impersonation_sessions")
}

model User {
  id              String    @id @default(uuid())
  tenantId        String?   @map("tenant_id") // Nullable for SUPER_ADMIN users
  tenant          Tenant?   @relation(fields: [tenantId], references: [id])
  auth0Id         String    @unique @map("auth0_id")
  email           String
  name            String
  role            UserRole // User role (SUPER_ADMIN for platform admins, OWNER/ADMIN/etc for tenant users)
  isActive        Boolean   @default(true) @map("is_active")
  lastLoginAt     DateTime? @map("last_login_at")
  currentTenantId String?   @map("current_tenant_id") // Active tenant in current session (for SUPER_ADMIN impersonation)
  createdAt       DateTime  @default(now()) @map("created_at")
  updatedAt       DateTime  @updatedAt @map("updated_at")

  tenantRoles             UserTenantRole[] @relation("UserTenantRoles")
  receivedInvitations     Invitation[]
  reviewedCategorizations Categorization[] @relation("ReviewedCategorizations")
  sarsSubmissions         SarsSubmission[]
  reconciliations         Reconciliation[] @relation("ReconciliationReconciler")

  // TASK-RECON-004: Duplicate Resolution tracking
  duplicateResolutions DuplicateResolution[] @relation("DuplicateResolutionResolver")

  // TASK-RECON-005: Manual Match History tracking
  manualMatchHistory ManualMatchHistory[] @relation("ManualMatchPerformer")

  // TASK-RECON-036: Accrued Bank Charge matching
  accruedChargeMatches AccruedBankCharge[] @relation("AccruedChargeMatcher")

  // TASK-RECON-037: Xero Transaction Split tracking
  xeroSplitsCreated   XeroTransactionSplit[] @relation("XeroSplitCreator")
  xeroSplitsConfirmed XeroTransactionSplit[] @relation("XeroSplitConfirmer")

  // TASK-COMM-001: Ad-hoc Communication
  broadcastMessagesCreated BroadcastMessage[] @relation("BroadcastMessageCreatedBy")

  // TASK-ADMIN-001: Impersonation Sessions (AWS SSO-style tenant switching)
  impersonationSessions ImpersonationSession[] @relation("SuperAdminSessions")

  // TASK-ACCT-012: Quotes created by user
  quotesCreated Quote[]

  // TASK-ACCT-013: Supplier bills created by user
  supplierBillsCreated SupplierBill[]

  // TASK-ACCT-003: Opening balance verification
  openingBalancesVerified        OpeningBalance[]
  openingBalanceImportsProcessed OpeningBalanceImport[]

  @@unique([tenantId, email])
  @@index([tenantId])
  @@index([auth0Id])
  @@index([currentTenantId])
  @@map("users")
}

model AuditLog {
  id            String      @id @default(uuid())
  tenantId      String      @map("tenant_id")
  userId        String?     @map("user_id")
  agentId       String?     @map("agent_id")
  entityType    String      @map("entity_type")
  entityId      String      @map("entity_id")
  action        AuditAction
  beforeValue   Json?       @map("before_value")
  afterValue    Json?       @map("after_value")
  changeSummary String?     @map("change_summary")
  ipAddress     String?     @map("ip_address") @db.VarChar(45)
  userAgent     String?     @map("user_agent")
  createdAt     DateTime    @default(now()) @map("created_at")

  // NOTE: No @updatedAt - this table is IMMUTABLE
  // NOTE: No foreign keys - intentional for immutability

  @@index([tenantId, entityType, entityId])
  @@index([tenantId, createdAt])
  @@index([userId, createdAt])
  @@index([action])
  @@map("audit_logs")
}

enum DuplicateStatus {
  NONE
  FLAGGED
  RESOLVED
}

model Transaction {
  id                    String            @id @default(uuid())
  tenantId              String            @map("tenant_id")
  xeroTransactionId     String?           @unique @map("xero_transaction_id")
  bankAccount           String            @map("bank_account") @db.VarChar(50)
  date                  DateTime          @db.Date
  description           String
  payeeName             String?           @map("payee_name") @db.VarChar(200)
  reference             String?           @db.VarChar(100)
  amountCents           Int               @map("amount_cents")
  isCredit              Boolean           @map("is_credit")
  source                ImportSource
  importBatchId         String?           @map("import_batch_id")
  status                TransactionStatus @default(PENDING)
  isReconciled          Boolean           @default(false) @map("is_reconciled")
  reconciledAt          DateTime?         @map("reconciled_at")
  isDeleted             Boolean           @default(false) @map("is_deleted")
  deletedAt             DateTime?         @map("deleted_at")
  transactionHash       String?           @map("transaction_hash") @db.VarChar(64)
  duplicateOfId         String?           @map("duplicate_of_id")
  duplicateStatus       DuplicateStatus   @default(NONE) @map("duplicate_status")
  reversesTransactionId String?           @map("reverses_transaction_id")
  isReversal            Boolean           @default(false) @map("is_reversal")
  xeroAccountCode       String?           @map("xero_account_code") @db.VarChar(20)
  createdAt             DateTime          @default(now()) @map("created_at")
  updatedAt             DateTime          @updatedAt @map("updated_at")

  tenant                Tenant                 @relation(fields: [tenantId], references: [id])
  duplicateOf           Transaction?           @relation("TransactionDuplicates", fields: [duplicateOfId], references: [id], onDelete: SetNull)
  duplicates            Transaction[]          @relation("TransactionDuplicates")
  reversesTransaction   Transaction?           @relation("TransactionReversals", fields: [reversesTransactionId], references: [id], onDelete: SetNull)
  reversals             Transaction[]          @relation("TransactionReversals")
  categorizations       Categorization[]
  payments              Payment[]
  categorizationMetrics CategorizationMetric[]
  bankStatementMatches  BankStatementMatch[]
  categorizationJournal CategorizationJournal?

  // TASK-RECON-005: Manual Match History tracking
  previousMatchHistory ManualMatchHistory[] @relation("PreviousMatchedTransaction")
  newMatchHistory      ManualMatchHistory[] @relation("NewMatchedTransaction")

  // TASK-RECON-036: Accrued Bank Charges
  accruedChargesAsSource AccruedBankCharge[] @relation("AccruedChargeSource")
  accruedChargesAsCharge AccruedBankCharge[] @relation("AccruedChargeActual")

  // TASK-RECON-037: Xero Transaction Splitting
  xeroSplitsAsBankTransaction XeroTransactionSplit[] @relation("XeroSplitBankTransaction")

  // TASK-ACCT-013: Supplier Management
  supplierId           String?               @map("supplier_id")
  supplier             Supplier?             @relation(fields: [supplierId], references: [id])
  supplierBillPayments SupplierBillPayment[]

  @@index([tenantId, date])
  @@index([tenantId, status])
  @@index([tenantId, payeeName])
  @@index([tenantId, isReconciled])
  @@index([tenantId, transactionHash])
  @@index([tenantId, duplicateStatus])
  @@index([tenantId, isReversal])
  @@index([reversesTransactionId])
  @@map("transactions")
}

model Categorization {
  id               String               @id @default(uuid())
  transactionId    String               @map("transaction_id")
  accountCode      String               @map("account_code") @db.VarChar(20)
  accountName      String               @map("account_name") @db.VarChar(100)
  confidenceScore  Decimal              @map("confidence_score") @db.Decimal(5, 2)
  reasoning        String?
  source           CategorizationSource
  isSplit          Boolean              @default(false) @map("is_split")
  splitAmountCents Int?                 @map("split_amount_cents")
  vatAmountCents   Int?                 @map("vat_amount_cents")
  vatType          VatType              @default(STANDARD) @map("vat_type")
  reviewedBy       String?              @map("reviewed_by")
  reviewedAt       DateTime?            @map("reviewed_at")
  createdAt        DateTime             @default(now()) @map("created_at")
  updatedAt        DateTime             @updatedAt @map("updated_at")

  transaction Transaction @relation(fields: [transactionId], references: [id])
  reviewer    User?       @relation("ReviewedCategorizations", fields: [reviewedBy], references: [id])

  @@index([transactionId])
  @@index([accountCode])
  @@map("categorizations")
}

model PayeePattern {
  id                    String   @id @default(uuid())
  tenantId              String   @map("tenant_id")
  payeePattern          String   @map("payee_pattern") @db.VarChar(200)
  payeeAliases          Json     @default("[]") @map("payee_aliases")
  defaultAccountCode    String   @map("default_account_code") @db.VarChar(20)
  defaultAccountName    String   @map("default_account_name") @db.VarChar(100)
  confidenceBoost       Decimal  @default(0) @map("confidence_boost") @db.Decimal(5, 2)
  matchCount            Int      @default(0) @map("match_count")
  isRecurring           Boolean  @default(false) @map("is_recurring")
  expectedAmountCents   Int?     @map("expected_amount_cents")
  amountVariancePercent Decimal? @map("amount_variance_percent") @db.Decimal(5, 2)
  createdAt             DateTime @default(now()) @map("created_at")
  updatedAt             DateTime @updatedAt @map("updated_at")

  tenant Tenant @relation(fields: [tenantId], references: [id])

  @@unique([tenantId, payeePattern])
  @@index([tenantId])
  @@map("payee_patterns")
}

model FeeStructure {
  id                     String    @id @default(uuid())
  tenantId               String    @map("tenant_id")
  name                   String    @db.VarChar(100)
  description            String?
  feeType                FeeType   @map("fee_type")
  amountCents            Int       @map("amount_cents")
  registrationFeeCents   Int       @default(0) @map("registration_fee_cents")
  reRegistrationFeeCents Int       @default(0) @map("re_registration_fee_cents")
  vatInclusive           Boolean   @default(true) @map("vat_inclusive")
  siblingDiscountPercent Decimal?  @map("sibling_discount_percent") @db.Decimal(5, 2)
  effectiveFrom          DateTime  @map("effective_from") @db.Date
  effectiveTo            DateTime? @map("effective_to") @db.Date
  isActive               Boolean   @default(true) @map("is_active")
  createdAt              DateTime  @default(now()) @map("created_at")
  updatedAt              DateTime  @updatedAt @map("updated_at")

  tenant      Tenant       @relation(fields: [tenantId], references: [id])
  enrollments Enrollment[]

  // TASK-ACCT-012: Quote lines linking to fee structure
  quoteLines QuoteLine[]

  @@index([tenantId, isActive])
  @@index([tenantId, effectiveFrom])
  @@map("fee_structures")
}

model Enrollment {
  id                     String           @id @default(uuid())
  tenantId               String           @map("tenant_id")
  childId                String           @map("child_id")
  feeStructureId         String           @map("fee_structure_id")
  startDate              DateTime         @map("start_date") @db.Date
  endDate                DateTime?        @map("end_date") @db.Date
  status                 EnrollmentStatus @default(ACTIVE)
  siblingDiscountApplied Boolean          @default(false) @map("sibling_discount_applied")
  customFeeOverrideCents Int?             @map("custom_fee_override_cents")
  notes                  String?
  // TASK-ENROL-008: Welcome Pack Delivery Integration
  welcomePackSentAt      DateTime?        @map("welcome_pack_sent_at")
  createdAt              DateTime         @default(now()) @map("created_at")
  updatedAt              DateTime         @updatedAt @map("updated_at")

  tenant       Tenant       @relation(fields: [tenantId], references: [id])
  child        Child        @relation(fields: [childId], references: [id], onDelete: Cascade)
  feeStructure FeeStructure @relation(fields: [feeStructureId], references: [id])

  @@index([tenantId, childId, status])
  @@index([tenantId, status, startDate])
  @@map("enrollments")
}

model Parent {
  id               String           @id @default(uuid())
  tenantId         String           @map("tenant_id")
  xeroContactId    String?          @unique @map("xero_contact_id")
  firstName        String           @map("first_name") @db.VarChar(100)
  lastName         String           @map("last_name") @db.VarChar(100)
  email            String?          @db.VarChar(255)
  phone            String?          @db.VarChar(20)
  whatsapp         String?          @db.VarChar(20)
  preferredContact PreferredContact @default(EMAIL) @map("preferred_contact")
  whatsappOptIn    Boolean          @default(false) @map("whatsapp_opt_in")
  smsOptIn         Boolean          @default(false) @map("sms_opt_in")
  idNumber         String?          @map("id_number") @db.VarChar(20)
  address          String?
  notes            String?
  isActive         Boolean          @default(true) @map("is_active")
  // TASK-DATA-003: Soft delete support
  deletedAt        DateTime?        @map("deleted_at")
  createdAt        DateTime         @default(now()) @map("created_at")
  updatedAt        DateTime         @updatedAt @map("updated_at")

  tenant         Tenant          @relation(fields: [tenantId], references: [id])
  children       Child[]
  invoices       Invoice[]
  reminders      Reminder[]
  creditBalances CreditBalance[]
  statements     Statement[]

  // TASK-XERO-010: Xero Contact Mapping
  xeroContactMapping XeroContactMapping?

  // TASK-WA-001: WhatsApp Message History
  whatsAppMessages WhatsAppMessage[]

  // TASK-ACCT-012: Quotes for parent
  quotes Quote[]

  // TASK-ACCT-011: Payment links and gateway transactions
  paymentLinks               PaymentLink[]
  paymentGatewayTransactions PaymentGatewayTransaction[]

  // TASK-ONBOARD: Parent onboarding documents
  generatedDocuments ParentGeneratedDocument[]

  @@unique([tenantId, email])
  @@index([tenantId])
  @@index([tenantId, lastName, firstName])
  @@index([tenantId, deletedAt])
  @@map("parents")
}

// TASK-ONBOARD: Parent Generated Documents
// Stores fee agreements, consent forms, and other onboarding documents
model ParentGeneratedDocument {
  id           String   @id @default(uuid())
  parentId     String   @map("parent_id")
  tenantId     String   @map("tenant_id")
  documentType String   @map("document_type") @db.VarChar(50) // FEE_AGREEMENT, CONSENT_FORMS, WELCOME_PACK
  fileName     String   @map("file_name") @db.VarChar(255)
  filePath     String   @map("file_path") @db.VarChar(500)
  mimeType     String   @default("application/pdf") @map("mime_type") @db.VarChar(100)
  generatedAt  DateTime @default(now()) @map("generated_at")
  signedAt     DateTime? @map("signed_at")
  signedByName String?  @map("signed_by_name") @db.VarChar(200)
  signedByIp   String?  @map("signed_by_ip") @db.VarChar(45)
  acknowledged Boolean  @default(false)
  metadata     String?  // JSON for media consent, authorized collectors, etc.
  createdAt    DateTime @default(now()) @map("created_at")
  updatedAt    DateTime @updatedAt @map("updated_at")

  parent Parent @relation(fields: [parentId], references: [id], onDelete: Cascade)

  @@index([parentId])
  @@index([parentId, documentType])
  @@index([tenantId])
  @@map("parent_generated_documents")
}

// TASK-PAY-018: Credit Balance for Overpayments
enum CreditBalanceSourceType {
  OVERPAYMENT
  REFUND
  CREDIT_NOTE
  ADJUSTMENT
}

model CreditBalance {
  id                 String                  @id @default(uuid())
  tenantId           String                  @map("tenant_id")
  parentId           String                  @map("parent_id")
  amountCents        Int                     @map("amount_cents")
  sourceType         CreditBalanceSourceType @map("source_type")
  sourceId           String?                 @map("source_id")
  description        String?
  appliedToInvoiceId String?                 @map("applied_to_invoice_id")
  appliedAt          DateTime?               @map("applied_at")
  isApplied          Boolean                 @default(false) @map("is_applied")
  createdAt          DateTime                @default(now()) @map("created_at")
  updatedAt          DateTime                @updatedAt @map("updated_at")

  tenant           Tenant   @relation(fields: [tenantId], references: [id])
  parent           Parent   @relation(fields: [parentId], references: [id])
  appliedToInvoice Invoice? @relation("CreditAppliedToInvoice", fields: [appliedToInvoiceId], references: [id])

  @@index([tenantId, parentId])
  @@index([tenantId, isApplied])
  @@map("credit_balances")
}

model Child {
  id               String    @id @default(uuid())
  tenantId         String    @map("tenant_id")
  parentId         String    @map("parent_id")
  firstName        String    @map("first_name") @db.VarChar(100)
  lastName         String    @map("last_name") @db.VarChar(100)
  dateOfBirth      DateTime  @map("date_of_birth") @db.Date
  gender           Gender?
  medicalNotes     String?   @map("medical_notes")
  emergencyContact String?   @map("emergency_contact") @db.VarChar(200)
  emergencyPhone   String?   @map("emergency_phone") @db.VarChar(20)
  isActive         Boolean   @default(true) @map("is_active")
  // TASK-DATA-003: Soft delete support
  deletedAt        DateTime? @map("deleted_at")
  createdAt        DateTime  @default(now()) @map("created_at")
  updatedAt        DateTime  @updatedAt @map("updated_at")

  tenant      Tenant       @relation(fields: [tenantId], references: [id])
  parent      Parent       @relation(fields: [parentId], references: [id], onDelete: Cascade)
  enrollments Enrollment[]
  invoices    Invoice[]

  @@index([tenantId])
  @@index([tenantId, parentId])
  @@index([tenantId, isActive])
  @@index([tenantId, deletedAt])
  @@map("children")
}

model Invoice {
  id                 String          @id @default(uuid())
  tenantId           String          @map("tenant_id")
  xeroInvoiceId      String?         @unique @map("xero_invoice_id")
  invoiceNumber      String          @map("invoice_number") @db.VarChar(50)
  parentId           String          @map("parent_id")
  childId            String          @map("child_id")
  billingPeriodStart DateTime        @map("billing_period_start") @db.Date
  billingPeriodEnd   DateTime        @map("billing_period_end") @db.Date
  issueDate          DateTime        @map("issue_date") @db.Date
  dueDate            DateTime        @map("due_date") @db.Date
  subtotalCents      Int             @map("subtotal_cents")
  vatCents           Int             @default(0) @map("vat_cents")
  vatRate            Decimal         @default(0) @map("vat_rate") @db.Decimal(5, 2)
  totalCents         Int             @map("total_cents")
  amountPaidCents    Int             @default(0) @map("amount_paid_cents")
  status             InvoiceStatus   @default(DRAFT)
  deliveryMethod     DeliveryMethod? @map("delivery_method")
  deliveryStatus     DeliveryStatus? @map("delivery_status")
  deliveredAt        DateTime?       @map("delivered_at")
  deliveryRetryCount Int             @default(0) @map("delivery_retry_count")
  pdfUrl             String?         @map("pdf_url") @db.VarChar(500)
  notes              String?
  isDeleted          Boolean         @default(false) @map("is_deleted")
  createdAt          DateTime        @default(now()) @map("created_at")
  updatedAt          DateTime        @updatedAt @map("updated_at")

  tenant         Tenant               @relation(fields: [tenantId], references: [id])
  parent         Parent               @relation(fields: [parentId], references: [id])
  child          Child                @relation(fields: [childId], references: [id])
  lines          InvoiceLine[]
  payments       Payment[]
  reminders      Reminder[]
  adHocCharges   AdHocCharge[]
  deliveryLogs   InvoiceDeliveryLog[]
  creditBalances CreditBalance[]      @relation("CreditAppliedToInvoice")

  // TASK-XERO-009: Bidirectional Invoice Sync
  xeroInvoiceMapping XeroInvoiceMapping?

  // TASK-RECON-035: Split Transaction Matching
  splitMatchComponents SplitMatchComponent[]

  // TASK-ACCT-012: Quotes converted to this invoice
  quotesConverted Quote[]

  // TASK-ACCT-011: Payment gateway
  paymentLinks               PaymentLink[]
  paymentGatewayTransactions PaymentGatewayTransaction[]

  @@unique([tenantId, invoiceNumber])
  @@index([tenantId, parentId])
  @@index([tenantId, status])
  @@index([tenantId, dueDate])
  @@index([xeroInvoiceId])
  @@map("invoices")
}

model InvoiceLine {
  id             String   @id @default(uuid())
  invoiceId      String   @map("invoice_id")
  description    String   @db.VarChar(500)
  quantity       Decimal  @default(1) @db.Decimal(10, 2)
  unitPriceCents Int      @map("unit_price_cents")
  discountCents  Int      @default(0) @map("discount_cents")
  subtotalCents  Int      @map("subtotal_cents")
  vatCents       Int      @default(0) @map("vat_cents")
  totalCents     Int      @map("total_cents")
  lineType       LineType @map("line_type")
  accountCode    String?  @map("account_code") @db.VarChar(20)
  sortOrder      Int      @default(0) @map("sort_order")
  adHocChargeId  String?  @map("ad_hoc_charge_id")
  createdAt      DateTime @default(now()) @map("created_at")

  invoice     Invoice      @relation(fields: [invoiceId], references: [id], onDelete: Cascade)
  adHocCharge AdHocCharge? @relation(fields: [adHocChargeId], references: [id])

  @@index([invoiceId, sortOrder])
  @@index([adHocChargeId])
  @@map("invoice_lines")
}

// TASK-BILL-035: Invoice Delivery Log for webhook tracking
model InvoiceDeliveryLog {
  id                String   @id @default(uuid())
  invoiceId         String   @map("invoice_id")
  tenantId          String   @map("tenant_id")
  channel           String   @db.VarChar(20) // EMAIL, WHATSAPP
  status            String   @db.VarChar(20) // DeliveryStatus
  eventType         String   @map("event_type") @db.VarChar(50)
  externalMessageId String?  @map("external_message_id") @db.VarChar(255)
  metadata          Json     @default("{}")
  occurredAt        DateTime @map("occurred_at")
  createdAt         DateTime @default(now()) @map("created_at")

  invoice Invoice @relation(fields: [invoiceId], references: [id])
  tenant  Tenant  @relation(fields: [tenantId], references: [id])

  @@index([invoiceId, occurredAt])
  @@index([externalMessageId])
  @@index([tenantId, channel])
  @@map("invoice_delivery_logs")
}

// TASK-BILL-041: Atomic invoice number counter for race condition prevention
model InvoiceNumberCounter {
  tenantId     String   @map("tenant_id")
  year         Int
  currentValue Int      @default(0) @map("current_value")
  createdAt    DateTime @default(now()) @map("created_at")
  updatedAt    DateTime @updatedAt @map("updated_at")

  tenant Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  @@id([tenantId, year])
  @@map("invoice_number_counters")
}

// TASK-ACCT-011: Atomic employee number counter for race condition prevention
model EmployeeNumberCounter {
  tenantId     String   @map("tenant_id")
  year         Int
  currentValue Int      @default(0) @map("current_value")
  createdAt    DateTime @default(now()) @map("created_at")
  updatedAt    DateTime @updatedAt @map("updated_at")

  tenant Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  @@id([tenantId, year])
  @@map("employee_number_counters")
}

model Payment {
  id              String    @id @default(uuid())
  tenantId        String    @map("tenant_id")
  xeroPaymentId   String?   @unique @map("xero_payment_id")
  transactionId   String?   @map("transaction_id")
  invoiceId       String    @map("invoice_id")
  amountCents     Int       @map("amount_cents")
  paymentDate     DateTime  @map("payment_date") @db.Date
  reference       String?   @db.VarChar(100)
  matchType       MatchType @map("match_type")
  matchConfidence Decimal?  @map("match_confidence") @db.Decimal(5, 2)
  matchedBy       MatchedBy @map("matched_by")
  isReversed      Boolean   @default(false) @map("is_reversed")
  reversedAt      DateTime? @map("reversed_at")
  reversalReason  String?   @map("reversal_reason") @db.Text
  // TASK-DATA-003: Soft delete support
  deletedAt       DateTime? @map("deleted_at")
  createdAt       DateTime  @default(now()) @map("created_at")
  updatedAt       DateTime  @updatedAt @map("updated_at")

  tenant               Tenant                @relation(fields: [tenantId], references: [id])
  transaction          Transaction?          @relation(fields: [transactionId], references: [id])
  invoice              Invoice               @relation(fields: [invoiceId], references: [id])
  splitMatchComponents SplitMatchComponent[]

  // TASK-XERO-010: Xero Payment Mapping
  xeroPaymentMapping XeroPaymentMapping?

  // TASK-ACCT-011: Payment gateway transactions linked to this payment
  gatewayTransactions PaymentGatewayTransaction[]

  @@index([tenantId, transactionId])
  @@index([tenantId, invoiceId])
  @@index([xeroPaymentId])
  @@index([tenantId, deletedAt])
  @@map("payments")
}

model Staff {
  id                String         @id @default(uuid())
  tenantId          String         @map("tenant_id")
  employeeNumber    String?        @map("employee_number") @db.VarChar(50)
  firstName         String         @map("first_name") @db.VarChar(100)
  lastName          String         @map("last_name") @db.VarChar(100)
  idNumber          String         @map("id_number") @db.VarChar(13)
  taxNumber         String?        @map("tax_number") @db.VarChar(20)
  email             String?        @db.VarChar(255)
  phone             String?        @db.VarChar(20)
  dateOfBirth       DateTime       @map("date_of_birth") @db.Date
  startDate         DateTime       @map("start_date") @db.Date
  endDate           DateTime?      @map("end_date") @db.Date
  employmentType    EmploymentType @map("employment_type")
  payFrequency      PayFrequency   @default(MONTHLY) @map("pay_frequency")
  basicSalaryCents  Int            @map("basic_salary_cents")
  bankName          String?        @map("bank_name") @db.VarChar(100)
  bankAccount       String?        @map("bank_account") @db.VarChar(20)
  bankBranchCode    String?        @map("bank_branch_code") @db.VarChar(10)
  bankAccountType   String?        @map("bank_account_type") @db.VarChar(50)
  medicalAidMembers Int            @default(0) @map("medical_aid_members")
  isActive          Boolean        @default(true) @map("is_active")

  // TASK-STAFF-001: Additional onboarding fields
  // Emergency contact details
  emergencyContactName     String? @map("emergency_contact_name") @db.VarChar(200)
  emergencyContactPhone    String? @map("emergency_contact_phone") @db.VarChar(20)
  emergencyContactRelation String? @map("emergency_contact_relation") @db.VarChar(50)

  // Address details
  address    String? @db.VarChar(500)
  suburb     String? @db.VarChar(100)
  city       String? @db.VarChar(100)
  province   String? @db.VarChar(100)
  postalCode String? @map("postal_code") @db.VarChar(10)

  // Employment details
  department   String? @db.VarChar(100)
  position     String? @db.VarChar(100)
  workSchedule String? @map("work_schedule") @db.VarChar(100)
  hoursPerWeek Int?    @map("hours_per_week")
  reportingTo  String? @map("reporting_to") @db.VarChar(200)

  // Tax details
  taxStatus     String? @map("tax_status") @db.VarChar(50)
  paymentMethod String? @map("payment_method") @db.VarChar(50)

  // TASK-DATA-003: Soft delete support
  deletedAt DateTime? @map("deleted_at")

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  tenant      Tenant            @relation(fields: [tenantId], references: [id])
  payrolls    Payroll[]
  documents   StaffDocument[]
  onboarding  StaffOnboarding?
  offboarding StaffOffboarding?

  // TASK-STAFF-004: SimplePay Integration
  simplePayMapping  SimplePayEmployeeMapping?
  simplePayPayslips SimplePayPayslipImport[]

  // TASK-SPAY-001: Leave Management
  leaveRequests LeaveRequest[]

  // TASK-SPAY-003: Payroll Adjustments
  payrollAdjustments PayrollAdjustment[]

  // TASK-SPAY-004: Service Period Management
  servicePeriodSyncs ServicePeriodSync[]

  // TASK-SPAY-006: Profile Mapping Sync
  profileMappingSyncs ProfileMappingSync[]

  // TASK-SPAY-008: Employee Setup Pipeline
  employeeSetupLog EmployeeSetupLog?

  // TASK-STAFF-006: UI-19 Deadline Tracking
  ui19Submissions UI19Submission[]

  @@unique([tenantId, idNumber])
  @@index([tenantId, isActive])
  @@index([tenantId, deletedAt])
  @@map("staff")
}

model SarsSubmission {
  id             String           @id @default(uuid())
  tenantId       String           @map("tenant_id")
  submissionType SubmissionType   @map("submission_type")
  periodStart    DateTime         @map("period_start") @db.Date
  periodEnd      DateTime         @map("period_end") @db.Date
  deadline       DateTime         @db.Date
  outputVatCents Int?             @map("output_vat_cents")
  inputVatCents  Int?             @map("input_vat_cents")
  netVatCents    Int?             @map("net_vat_cents")
  totalPayeCents Int?             @map("total_paye_cents")
  totalUifCents  Int?             @map("total_uif_cents")
  totalSdlCents  Int?             @map("total_sdl_cents")
  status         SubmissionStatus @default(DRAFT)
  submittedAt    DateTime?        @map("submitted_at")
  submittedBy    String?          @map("submitted_by")
  sarsReference  String?          @map("sars_reference") @db.VarChar(100)
  documentData   Json             @default("{}") @map("document_data")
  notes          String?          @db.Text
  isFinalized    Boolean          @default(false) @map("is_finalized")
  createdAt      DateTime         @default(now()) @map("created_at")
  updatedAt      DateTime         @updatedAt @map("updated_at")

  tenant    Tenant @relation(fields: [tenantId], references: [id])
  submitter User?  @relation(fields: [submittedBy], references: [id])

  @@unique([tenantId, submissionType, periodStart])
  @@index([tenantId, status])
  @@index([deadline])
  @@map("sars_submissions")
}

model Payroll {
  id                    String        @id @default(uuid())
  tenantId              String        @map("tenant_id")
  staffId               String        @map("staff_id")
  payPeriodStart        DateTime      @map("pay_period_start") @db.Date
  payPeriodEnd          DateTime      @map("pay_period_end") @db.Date
  basicSalaryCents      Int           @map("basic_salary_cents")
  overtimeCents         Int           @default(0) @map("overtime_cents")
  bonusCents            Int           @default(0) @map("bonus_cents")
  otherEarningsCents    Int           @default(0) @map("other_earnings_cents")
  grossSalaryCents      Int           @map("gross_salary_cents")
  payeCents             Int           @map("paye_cents")
  uifEmployeeCents      Int           @map("uif_employee_cents")
  uifEmployerCents      Int           @map("uif_employer_cents")
  otherDeductionsCents  Int           @default(0) @map("other_deductions_cents")
  netSalaryCents        Int           @map("net_salary_cents")
  medicalAidCreditCents Int           @default(0) @map("medical_aid_credit_cents")
  status                PayrollStatus @default(DRAFT)
  paymentDate           DateTime?     @map("payment_date") @db.Date
  createdAt             DateTime      @default(now()) @map("created_at")
  updatedAt             DateTime      @updatedAt @map("updated_at")

  tenant         Tenant          @relation(fields: [tenantId], references: [id])
  staff          Staff           @relation(fields: [staffId], references: [id])
  payrollJournal PayrollJournal?

  @@unique([tenantId, staffId, payPeriodStart])
  @@index([tenantId, status])
  @@index([tenantId, payPeriodStart])
  @@map("payrolls")
}

model Reconciliation {
  id                     String               @id @default(uuid())
  tenantId               String               @map("tenant_id")
  bankAccount            String               @map("bank_account") @db.VarChar(50)
  periodStart            DateTime             @map("period_start") @db.Date
  periodEnd              DateTime             @map("period_end") @db.Date
  openingBalanceCents    Int                  @map("opening_balance_cents")
  closingBalanceCents    Int                  @map("closing_balance_cents")
  calculatedBalanceCents Int                  @map("calculated_balance_cents")
  discrepancyCents       Int                  @default(0) @map("discrepancy_cents")
  status                 ReconciliationStatus @default(IN_PROGRESS)
  reconciledBy           String?              @map("reconciled_by")
  reconciledAt           DateTime?            @map("reconciled_at")
  notes                  String?              @db.Text
  createdAt              DateTime             @default(now()) @map("created_at")
  updatedAt              DateTime             @updatedAt @map("updated_at")

  tenant               Tenant               @relation(fields: [tenantId], references: [id])
  reconciler           User?                @relation("ReconciliationReconciler", fields: [reconciledBy], references: [id])
  bankStatementMatches BankStatementMatch[]

  @@unique([tenantId, bankAccount, periodStart])
  @@index([tenantId, status])
  @@map("reconciliations")
}

// TASK-RECON-019: Bank Statement to Xero Transaction Matching
model BankStatementMatch {
  id               String @id @default(uuid())
  tenantId         String @map("tenant_id")
  reconciliationId String @map("reconciliation_id")

  // Bank statement side
  bankDate        DateTime @map("bank_date") @db.Date
  bankDescription String   @map("bank_description")
  bankAmountCents Int      @map("bank_amount_cents")
  bankIsCredit    Boolean  @map("bank_is_credit")

  // Xero/CrecheBooks side (nullable if no match)
  transactionId   String?   @map("transaction_id")
  xeroDate        DateTime? @map("xero_date") @db.Date
  xeroDescription String?   @map("xero_description")
  xeroAmountCents Int?      @map("xero_amount_cents")
  xeroIsCredit    Boolean?  @map("xero_is_credit")

  // Match result
  status            BankStatementMatchStatus
  matchConfidence   Decimal?                 @map("match_confidence") @db.Decimal(5, 2)
  discrepancyReason String?                  @map("discrepancy_reason")

  // TASK-RECON-036: Fee adjustment tracking
  isFeeAdjustedMatch    Boolean @default(false) @map("is_fee_adjusted_match")
  accruedFeeAmountCents Int?    @map("accrued_fee_amount_cents")
  feeType               String? @map("fee_type") @db.VarChar(50) // ADT_DEPOSIT_FEE, CASH_DEPOSIT_FEE, etc.

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  tenant         Tenant         @relation(fields: [tenantId], references: [id])
  reconciliation Reconciliation @relation(fields: [reconciliationId], references: [id], onDelete: Cascade)
  transaction    Transaction?   @relation(fields: [transactionId], references: [id])

  // TASK-RECON-005: Manual Match History tracking
  manualMatchHistory ManualMatchHistory[]

  // TASK-RECON-036: Accrued bank charge tracking
  accruedBankCharge AccruedBankCharge?

  // TASK-RECON-037: Xero transaction split tracking
  xeroTransactionSplits XeroTransactionSplit[]

  @@index([tenantId])
  @@index([reconciliationId])
  @@index([transactionId])
  @@index([tenantId, status])
  @@map("bank_statement_matches")
}

// ============================================
// TASK-RECON-004: Duplicate Detection
// Tracks duplicate resolution decisions for bank statement imports
// ============================================

model DuplicateResolution {
  id           String    @id @default(uuid())
  tenantId     String    @map("tenant_id")
  compositeKey String    @map("composite_key") @db.VarChar(255)
  status       String    @default("PENDING") @db.VarChar(50)
  resolvedBy   String?   @map("resolved_by")
  resolvedAt   DateTime? @map("resolved_at")
  notes        String?   @db.Text
  createdAt    DateTime  @default(now()) @map("created_at")
  updatedAt    DateTime  @updatedAt @map("updated_at")

  tenant   Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  resolver User?  @relation("DuplicateResolutionResolver", fields: [resolvedBy], references: [id], onDelete: SetNull)

  @@unique([tenantId, compositeKey], name: "tenantId_compositeKey")
  @@index([tenantId])
  @@index([status])
  @@map("duplicate_resolutions")
}

// ============================================
// TASK-RECON-005: Manual Match History
// Tracks manual match/unmatch operations for audit and undo
// ============================================

model ManualMatchHistory {
  id                    String   @id @default(uuid())
  tenantId              String   @map("tenant_id")
  matchId               String   @map("match_id")
  previousTransactionId String?  @map("previous_transaction_id")
  newTransactionId      String?  @map("new_transaction_id")
  performedBy           String   @map("performed_by")
  performedAt           DateTime @default(now()) @map("performed_at")
  action                String   @db.VarChar(20)
  reason                String?  @db.Text

  tenant              Tenant             @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  match               BankStatementMatch @relation(fields: [matchId], references: [id], onDelete: Cascade)
  performer           User               @relation("ManualMatchPerformer", fields: [performedBy], references: [id])
  previousTransaction Transaction?       @relation("PreviousMatchedTransaction", fields: [previousTransactionId], references: [id], onDelete: SetNull)
  newTransaction      Transaction?       @relation("NewMatchedTransaction", fields: [newTransactionId], references: [id], onDelete: SetNull)

  @@index([tenantId])
  @@index([matchId])
  @@index([performedBy])
  @@index([performedAt(sort: Desc)])
  @@map("manual_match_history")
}

// ============================================
// TASK-RECON-035: Split Transaction Matching
// Matches single bank transaction to multiple invoices or vice versa
// ============================================

model SplitMatch {
  id                 String           @id @default(uuid())
  tenantId           String           @map("tenant_id")
  bankTransactionId  String           @map("bank_transaction_id")
  matchType          SplitMatchType   @map("match_type")
  totalAmountCents   Int              @map("total_amount_cents")
  matchedAmountCents Int              @map("matched_amount_cents")
  remainderCents     Int              @map("remainder_cents")
  status             SplitMatchStatus @default(PENDING)
  confirmedBy        String?          @map("confirmed_by")
  confirmedAt        DateTime?        @map("confirmed_at")
  createdAt          DateTime         @default(now()) @map("created_at")
  updatedAt          DateTime         @updatedAt @map("updated_at")

  tenant     Tenant                @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  components SplitMatchComponent[]

  @@index([tenantId, status])
  @@index([tenantId, bankTransactionId])
  @@map("split_matches")
}

model SplitMatchComponent {
  id           String   @id @default(uuid())
  splitMatchId String   @map("split_match_id")
  invoiceId    String?  @map("invoice_id")
  paymentId    String?  @map("payment_id")
  amountCents  Int      @map("amount_cents")
  createdAt    DateTime @default(now()) @map("created_at")

  splitMatch SplitMatch @relation(fields: [splitMatchId], references: [id], onDelete: Cascade)
  invoice    Invoice?   @relation(fields: [invoiceId], references: [id], onDelete: SetNull)
  payment    Payment?   @relation(fields: [paymentId], references: [id], onDelete: SetNull)

  @@index([splitMatchId])
  @@index([invoiceId])
  @@index([paymentId])
  @@map("split_match_components")
}

model XeroToken {
  id              String   @id @default(uuid())
  tenantId        String   @unique @map("tenant_id")
  xeroTenantId    String   @map("xero_tenant_id")
  encryptedTokens String   @map("encrypted_tokens") @db.Text
  tokenExpiresAt  DateTime @map("token_expires_at")
  createdAt       DateTime @default(now()) @map("created_at")
  updatedAt       DateTime @updatedAt @map("updated_at")

  tenant Tenant @relation(fields: [tenantId], references: [id])

  @@index([tenantId])
  @@map("xero_tokens")
}

// ============================================
// TASK-XERO-006: Chart of Accounts Database Sync
// Stores Xero Chart of Accounts for validation before pushing categorizations
// ============================================

enum XeroAccountStatus {
  ACTIVE
  ARCHIVED
}

model XeroAccount {
  id            String            @id @default(uuid())
  tenantId      String            @map("tenant_id")
  accountCode   String            @map("account_code") @db.VarChar(20)
  name          String            @db.VarChar(255)
  type          String            @db.VarChar(50)
  taxType       String?           @map("tax_type") @db.VarChar(50)
  status        XeroAccountStatus @default(ACTIVE)
  xeroAccountId String?           @map("xero_account_id") @db.VarChar(50)
  lastSyncedAt  DateTime          @map("last_synced_at")
  createdAt     DateTime          @default(now()) @map("created_at")
  updatedAt     DateTime          @updatedAt @map("updated_at")

  tenant Tenant @relation(fields: [tenantId], references: [id])

  @@unique([tenantId, accountCode])
  @@index([tenantId])
  @@index([tenantId, status])
  @@map("xero_accounts")
}

// TASK-TRANS-016: Bank Feed Integration via Xero API
enum BankConnectionStatus {
  ACTIVE
  DISCONNECTED
  ERROR
}

model BankConnection {
  id            String               @id @default(uuid())
  tenantId      String               @map("tenant_id")
  xeroAccountId String               @map("xero_account_id")
  accountName   String               @map("account_name")
  accountNumber String               @map("account_number")
  bankName      String               @map("bank_name")
  status        BankConnectionStatus @default(ACTIVE)
  errorMessage  String?              @map("error_message")
  connectedAt   DateTime             @default(now()) @map("connected_at")
  lastSyncAt    DateTime?            @map("last_sync_at")
  createdAt     DateTime             @default(now()) @map("created_at")
  updatedAt     DateTime             @updatedAt @map("updated_at")

  tenant Tenant @relation(fields: [tenantId], references: [id])

  @@unique([tenantId, xeroAccountId])
  @@index([tenantId, status])
  @@map("bank_connections")
}

// TASK-INT-101: Open Banking Integration via Stitch API
enum LinkedBankAccountStatus {
  PENDING // OAuth flow initiated, waiting for callback
  ACTIVE // Account linked and syncing
  EXPIRED // Consent expired (90 days)
  REVOKED // User revoked access
  ERROR // Sync error occurred
}

// TASK-INT-101: Linked bank accounts for Open Banking (Stitch API)
// Stores encrypted access/refresh tokens for SA banks (FNB, Standard, Nedbank, ABSA, Capitec)
model LinkedBankAccount {
  id                  String                  @id @default(uuid())
  tenantId            String                  @map("tenant_id")
  bankName            String                  @map("bank_name") @db.VarChar(100)
  accountHolderName   String?                 @map("account_holder_name") @db.VarChar(200)
  accountNumberMasked String                  @map("account_number_masked") @db.VarChar(20) // Last 4 digits only
  accountType         String                  @map("account_type") @db.VarChar(50) // CURRENT, SAVINGS, etc.
  stitchAccountId     String                  @unique @map("stitch_account_id") @db.VarChar(100)
  accessToken         String                  @map("access_token") @db.Text // AES-256 encrypted
  refreshToken        String                  @map("refresh_token") @db.Text // AES-256 encrypted
  tokenExpiresAt      DateTime                @map("token_expires_at")
  consentExpiresAt    DateTime                @map("consent_expires_at") // 90-day regulatory limit
  consentGrantedAt    DateTime                @map("consent_granted_at")
  lastSyncedAt        DateTime?               @map("last_synced_at")
  lastSyncError       String?                 @map("last_sync_error") @db.Text
  syncErrorCount      Int                     @default(0) @map("sync_error_count")
  status              LinkedBankAccountStatus @default(PENDING)
  metadata            Json? // Additional bank-specific metadata
  createdAt           DateTime                @default(now()) @map("created_at")
  updatedAt           DateTime                @updatedAt @map("updated_at")

  tenant          Tenant                @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  bankSyncHistory LinkedBankSyncEvent[]

  @@index([tenantId, status])
  @@index([consentExpiresAt])
  @@index([lastSyncedAt])
  @@map("linked_bank_accounts")
}

// TASK-INT-101: Bank sync event audit log
// Tracks all sync operations for compliance and debugging
model LinkedBankSyncEvent {
  id                    String    @id @default(uuid())
  linkedBankAccountId   String    @map("linked_bank_account_id")
  syncType              String    @map("sync_type") @db.VarChar(50) // SCHEDULED, MANUAL, REFRESH_TOKEN
  startedAt             DateTime  @default(now()) @map("started_at")
  completedAt           DateTime? @map("completed_at")
  transactionsFetched   Int?      @map("transactions_fetched")
  transactionsImported  Int?      @map("transactions_imported")
  transactionsDuplicate Int?      @map("transactions_duplicate")
  status                String    @map("status") @db.VarChar(20) // SUCCESS, FAILED, PARTIAL
  errorMessage          String?   @map("error_message") @db.Text
  errorCode             String?   @map("error_code") @db.VarChar(50)
  durationMs            Int?      @map("duration_ms")
  createdAt             DateTime  @default(now()) @map("created_at")

  linkedBankAccount LinkedBankAccount @relation(fields: [linkedBankAccountId], references: [id], onDelete: Cascade)

  @@index([linkedBankAccountId, startedAt])
  @@index([status])
  @@map("linked_bank_sync_events")
}

// TASK-TRANS-017: Transaction Categorization Accuracy Tracking
enum MetricEventType {
  CATEGORIZED
  CORRECTED
}

model CategorizationMetric {
  id                   String          @id @default(uuid())
  tenantId             String          @map("tenant_id")
  transactionId        String          @map("transaction_id")
  date                 DateTime        @default(now())
  eventType            MetricEventType @map("event_type")
  confidence           Decimal         @db.Decimal(5, 2)
  isAutoApplied        Boolean         @default(false) @map("is_auto_applied")
  originalAccountCode  String?         @map("original_account_code")
  correctedAccountCode String?         @map("corrected_account_code")
  createdAt            DateTime        @default(now()) @map("created_at")

  tenant      Tenant      @relation(fields: [tenantId], references: [id])
  transaction Transaction @relation(fields: [transactionId], references: [id])

  @@index([tenantId, date])
  @@index([tenantId, eventType])
  @@index([transactionId])
  @@map("categorization_metrics")
}

// TASK-BILL-038: Ad-Hoc Charge types for VAT categorization
enum AdHocChargeType {
  MEALS
  TRANSPORT
  LATE_PICKUP
  EXTRA_MURAL
  DAMAGED_EQUIPMENT
  OTHER
}

model AdHocCharge {
  id          String          @id @default(uuid())
  tenantId    String          @map("tenant_id")
  childId     String          @map("child_id")
  description String          @db.VarChar(500)
  amountCents Int             @map("amount_cents")
  chargeDate  DateTime        @map("charge_date") @db.Date
  // TASK-BILL-038: VAT compliance fields
  chargeType  AdHocChargeType @default(OTHER) @map("charge_type")
  isVatExempt Boolean         @default(false) @map("is_vat_exempt")
  vatCents    Int?            @map("vat_cents")
  invoicedAt  DateTime?       @map("invoiced_at")
  invoiceId   String?         @map("invoice_id")
  createdAt   DateTime        @default(now()) @map("created_at")
  updatedAt   DateTime        @updatedAt @map("updated_at")

  invoice      Invoice?      @relation(fields: [invoiceId], references: [id])
  invoiceLines InvoiceLine[]

  @@index([tenantId, childId])
  @@index([tenantId, invoicedAt])
  @@index([tenantId, chargeDate])
  @@map("ad_hoc_charges")
}

model Reminder {
  id              String          @id @default(uuid())
  tenantId        String          @map("tenant_id")
  invoiceId       String          @map("invoice_id")
  parentId        String          @map("parent_id")
  escalationLevel EscalationLevel @map("escalation_level")
  deliveryMethod  DeliveryMethod  @map("delivery_method")
  reminderStatus  ReminderStatus  @default(PENDING) @map("reminder_status")
  scheduledFor    DateTime?       @map("scheduled_for")
  sentAt          DateTime?       @map("sent_at")
  deliveredAt     DateTime?       @map("delivered_at")
  readAt          DateTime?       @map("read_at")
  content         String          @db.Text
  subject         String?         @db.VarChar(500)
  failureReason   String?         @map("failure_reason") @db.Text
  createdAt       DateTime        @default(now()) @map("created_at")
  updatedAt       DateTime        @updatedAt @map("updated_at")

  tenant  Tenant  @relation(fields: [tenantId], references: [id])
  invoice Invoice @relation(fields: [invoiceId], references: [id])
  parent  Parent  @relation(fields: [parentId], references: [id])

  @@index([tenantId, invoiceId])
  @@index([tenantId, parentId])
  @@index([tenantId, scheduledFor])
  @@map("reminders")
}

// TASK-TRANS-034: Xero Sync REST API Endpoints
model XeroOAuthState {
  id           String   @id @default(uuid())
  tenantId     String   @unique @map("tenant_id")
  codeVerifier String   @map("code_verifier") @db.Text
  state        String   @db.Text
  expiresAt    DateTime @map("expires_at")
  createdAt    DateTime @default(now()) @map("created_at")

  tenant Tenant @relation(fields: [tenantId], references: [id])

  @@index([tenantId])
  @@map("xero_oauth_states")
}

// TASK-FEAT-102: Automated Arrears Reminders Configuration
// Tenant-level settings for automated arrears reminders
model ReminderConfig {
  id             String   @id @default(uuid())
  tenantId       String   @unique @map("tenant_id")
  enabled        Boolean  @default(true)
  level1Days     Int      @default(7) @map("level_1_days")
  level2Days     Int      @default(14) @map("level_2_days")
  level3Days     Int      @default(30) @map("level_3_days")
  level4Days     Int      @default(60) @map("level_4_days")
  ccAdminLevel   Int      @default(3) @map("cc_admin_level") // CC admin on level 3+
  sendHoursStart Int      @default(8) @map("send_hours_start") // 8 AM
  sendHoursEnd   Int      @default(18) @map("send_hours_end") // 6 PM
  maxPerDay      Int      @default(1) @map("max_per_day") // Max 1 reminder per invoice per day
  adminEmail     String?  @map("admin_email") @db.VarChar(255) // Optional override for admin notifications
  createdAt      DateTime @default(now()) @map("created_at")
  updatedAt      DateTime @updatedAt @map("updated_at")

  tenant Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  @@map("reminder_configs")
}

// TASK-PAY-017: Tenant-Customizable Reminder Templates
model ReminderTemplate {
  id           String   @id @default(uuid())
  tenantId     String   @map("tenant_id")
  stage        String   @db.VarChar(20) // FIRST, SECOND, FINAL, ESCALATED
  daysOverdue  Int      @map("days_overdue")
  channels     String[] // email, whatsapp
  emailSubject String?  @map("email_subject") @db.VarChar(500)
  emailBody    String?  @map("email_body") @db.Text
  whatsappBody String?  @map("whatsapp_body") @db.Text
  isActive     Boolean  @default(true) @map("is_active")
  createdAt    DateTime @default(now()) @map("created_at")
  updatedAt    DateTime @updatedAt @map("updated_at")

  tenant Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  @@unique([tenantId, stage])
  @@index([tenantId])
  @@map("reminder_templates")
}

// TASK-USER-001: Multi-Tenant User Role Assignment
model UserTenantRole {
  id        String   @id @default(uuid())
  userId    String   @map("user_id")
  tenantId  String   @map("tenant_id")
  role      UserRole
  isActive  Boolean  @default(true) @map("is_active")
  joinedAt  DateTime @default(now()) @map("joined_at")
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  user   User   @relation("UserTenantRoles", fields: [userId], references: [id], onDelete: Cascade)
  tenant Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  @@unique([userId, tenantId])
  @@index([userId])
  @@index([tenantId])
  @@index([tenantId, isActive])
  @@map("user_tenant_roles")
}

// TASK-USER-001: Invitation System for Multi-Tenant Users
model Invitation {
  id         String           @id @default(uuid())
  email      String           @db.VarChar(255)
  tenantId   String           @map("tenant_id")
  role       UserRole
  status     InvitationStatus @default(PENDING)
  invitedBy  String?          @map("invited_by")
  acceptedBy String?          @map("accepted_by")
  expiresAt  DateTime         @map("expires_at")
  acceptedAt DateTime?        @map("accepted_at")
  revokedAt  DateTime?        @map("revoked_at")
  createdAt  DateTime         @default(now()) @map("created_at")
  updatedAt  DateTime         @updatedAt @map("updated_at")

  tenant       Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  acceptedUser User?  @relation(fields: [acceptedBy], references: [id])

  @@unique([email, tenantId, status])
  @@index([tenantId])
  @@index([email])
  @@index([status])
  @@index([expiresAt])
  @@map("invitations")
}

// TASK-STMT-001: Statement Entity and Data Model (Phase 12)
enum StatementStatus {
  DRAFT
  FINAL
  DELIVERED
  CANCELLED
}

enum StatementLineType {
  OPENING_BALANCE
  INVOICE
  PAYMENT
  CREDIT_NOTE
  ADJUSTMENT
  CLOSING_BALANCE
}

model Statement {
  id                  String          @id @default(uuid())
  tenantId            String          @map("tenant_id")
  parentId            String          @map("parent_id")
  statementNumber     String          @map("statement_number")
  periodStart         DateTime        @map("period_start") @db.Date
  periodEnd           DateTime        @map("period_end") @db.Date
  openingBalanceCents Int             @default(0) @map("opening_balance_cents")
  totalChargesCents   Int             @default(0) @map("total_charges_cents")
  totalPaymentsCents  Int             @default(0) @map("total_payments_cents")
  totalCreditsCents   Int             @default(0) @map("total_credits_cents")
  closingBalanceCents Int             @default(0) @map("closing_balance_cents")
  status              StatementStatus @default(DRAFT)
  generatedAt         DateTime        @default(now()) @map("generated_at")
  deliveryStatus      String?         @map("delivery_status") @db.VarChar(20)
  deliveredAt         DateTime?       @map("delivered_at")
  deliveryChannel     String?         @map("delivery_channel") @db.VarChar(20)
  createdAt           DateTime        @default(now()) @map("created_at")
  updatedAt           DateTime        @updatedAt @map("updated_at")

  tenant Tenant          @relation(fields: [tenantId], references: [id])
  parent Parent          @relation(fields: [parentId], references: [id])
  lines  StatementLine[]

  @@unique([tenantId, statementNumber])
  @@index([tenantId, parentId])
  @@index([tenantId, periodStart, periodEnd])
  @@map("statements")
}

model StatementLine {
  id              String            @id @default(uuid())
  statementId     String            @map("statement_id")
  date            DateTime          @db.Date
  description     String
  lineType        StatementLineType @map("line_type")
  referenceNumber String?           @map("reference_number") @db.VarChar(100)
  referenceId     String?           @map("reference_id")
  debitCents      Int               @default(0) @map("debit_cents")
  creditCents     Int               @default(0) @map("credit_cents")
  balanceCents    Int               @default(0) @map("balance_cents")
  sortOrder       Int               @default(0) @map("sort_order")
  createdAt       DateTime          @default(now()) @map("created_at")

  statement Statement @relation(fields: [statementId], references: [id], onDelete: Cascade)

  @@index([statementId])
  @@map("statement_lines")
}

// TASK-XERO-001: Bi-directional Sync Conflict Resolution
enum ConflictType {
  UPDATE_UPDATE
  DELETE_UPDATE
  CREATE_CREATE
}

enum ConflictStatus {
  PENDING
  AUTO_RESOLVED
  MANUALLY_RESOLVED
  IGNORED
}

model SyncConflict {
  id              String         @id @default(uuid())
  tenantId        String         @map("tenant_id")
  entityType      String         @map("entity_type") @db.VarChar(50)
  entityId        String         @map("entity_id")
  conflictType    ConflictType   @map("conflict_type")
  localData       Json           @map("local_data")
  xeroData        Json           @map("xero_data")
  localModifiedAt DateTime       @map("local_modified_at")
  xeroModifiedAt  DateTime       @map("xero_modified_at")
  status          ConflictStatus @default(PENDING)
  resolvedBy      String?        @map("resolved_by")
  resolution      String?        @db.VarChar(50)
  resolvedAt      DateTime?      @map("resolved_at")
  createdAt       DateTime       @default(now()) @map("created_at")
  updatedAt       DateTime       @updatedAt @map("updated_at")

  @@index([tenantId, status])
  @@index([tenantId, entityType, entityId])
  @@index([createdAt])
  @@map("sync_conflicts")
}

// ============================================
// TASK-STAFF-001: Staff Onboarding Models
// ============================================

model StaffDocument {
  id              String         @id @default(uuid())
  tenantId        String         @map("tenant_id")
  staffId         String         @map("staff_id")
  documentType    DocumentType   @map("document_type")
  fileName        String         @map("file_name") @db.VarChar(255)
  fileUrl         String         @map("file_url") @db.VarChar(500)
  fileSize        Int            @map("file_size")
  mimeType        String         @map("mime_type") @db.VarChar(100)
  status          DocumentStatus @default(PENDING)
  uploadedAt      DateTime       @default(now()) @map("uploaded_at")
  verifiedAt      DateTime?      @map("verified_at")
  verifiedBy      String?        @map("verified_by")
  expiryDate      DateTime?      @map("expiry_date") @db.Date
  rejectionReason String?        @map("rejection_reason")
  notes           String?
  createdAt       DateTime       @default(now()) @map("created_at")
  updatedAt       DateTime       @updatedAt @map("updated_at")

  tenant Tenant @relation(fields: [tenantId], references: [id])
  staff  Staff  @relation(fields: [staffId], references: [id], onDelete: Cascade)

  @@index([tenantId, staffId])
  @@index([tenantId, documentType])
  @@map("staff_documents")
}

model StaffOnboarding {
  id                     String           @id @default(uuid())
  tenantId               String           @map("tenant_id")
  staffId                String           @unique @map("staff_id")
  status                 OnboardingStatus @default(NOT_STARTED)
  currentStep            String           @default("PERSONAL_INFO") @map("current_step") @db.VarChar(50)
  startedAt              DateTime?        @map("started_at")
  completedAt            DateTime?        @map("completed_at")
  completedBy            String?          @map("completed_by")
  welcomePackSentAt      DateTime?        @map("welcome_pack_sent_at")
  welcomePackGeneratedAt DateTime?        @map("welcome_pack_generated_at")
  notes                  String?
  createdAt              DateTime         @default(now()) @map("created_at")
  updatedAt              DateTime         @updatedAt @map("updated_at")

  tenant             Tenant                    @relation(fields: [tenantId], references: [id])
  staff              Staff                     @relation(fields: [staffId], references: [id], onDelete: Cascade)
  checklistItems     OnboardingChecklistItem[]
  generatedDocuments StaffGeneratedDocument[]

  @@index([tenantId])
  @@index([tenantId, status])
  @@map("staff_onboardings")
}

// TASK-STAFF-001: Auto-Generated Employment Documents
// Stores generated employment contracts, POPIA consent forms, and welcome packs
enum GeneratedDocumentType {
  EMPLOYMENT_CONTRACT
  POPIA_CONSENT
  WELCOME_PACK
}

model StaffGeneratedDocument {
  id           String                @id @default(uuid())
  onboardingId String                @map("onboarding_id")
  documentType GeneratedDocumentType @map("document_type")
  fileName     String                @map("file_name") @db.VarChar(255)
  filePath     String                @map("file_path") @db.VarChar(500)
  fileSize     Int                   @map("file_size")
  mimeType     String                @default("application/pdf") @map("mime_type") @db.VarChar(100)
  generatedAt  DateTime              @default(now()) @map("generated_at")
  signedAt     DateTime?             @map("signed_at")
  signedByName String?               @map("signed_by_name") @db.VarChar(200)
  signedByIp   String?               @map("signed_by_ip") @db.VarChar(45)
  acknowledged Boolean               @default(false)
  createdAt    DateTime              @default(now()) @map("created_at")
  updatedAt    DateTime              @updatedAt @map("updated_at")

  onboarding StaffOnboarding @relation(fields: [onboardingId], references: [id], onDelete: Cascade)

  @@index([onboardingId])
  @@index([onboardingId, documentType])
  @@map("staff_generated_documents")
}

model OnboardingChecklistItem {
  id           String              @id @default(uuid())
  onboardingId String              @map("onboarding_id")
  itemKey      String              @map("item_key") @db.VarChar(100)
  title        String              @db.VarChar(255)
  description  String?
  category     String              @db.VarChar(50)
  status       ChecklistItemStatus @default(NOT_STARTED)
  isRequired   Boolean             @default(true) @map("is_required")
  sortOrder    Int                 @default(0) @map("sort_order")
  completedAt  DateTime?           @map("completed_at")
  completedBy  String?             @map("completed_by")
  notes        String?
  createdAt    DateTime            @default(now()) @map("created_at")
  updatedAt    DateTime            @updatedAt @map("updated_at")

  onboarding StaffOnboarding @relation(fields: [onboardingId], references: [id], onDelete: Cascade)

  @@unique([onboardingId, itemKey])
  @@index([onboardingId])
  @@map("onboarding_checklist_items")
}

// ============================================
// TASK-STAFF-003: Xero Payroll Journal Integration
// ============================================

enum XeroAccountType {
  SALARY_EXPENSE
  UIF_EMPLOYER_EXPENSE
  SDL_EXPENSE
  PENSION_EXPENSE
  PAYE_PAYABLE
  UIF_PAYABLE
  SDL_PAYABLE
  PENSION_PAYABLE
  NET_PAY_CLEARING
  BONUS_EXPENSE
  OVERTIME_EXPENSE
  OTHER_DEDUCTION
}

enum PayrollJournalStatus {
  PENDING
  POSTED
  FAILED
  CANCELLED
}

// TASK-XERO-007: Categorization Journal Status
enum CategorizationJournalStatus {
  PENDING
  POSTED
  FAILED
  CANCELLED
}

model XeroAccountMapping {
  id              String          @id @default(uuid())
  tenantId        String          @map("tenant_id")
  accountType     XeroAccountType @map("account_type")
  xeroAccountId   String          @map("xero_account_id") @db.VarChar(50)
  xeroAccountCode String          @map("xero_account_code") @db.VarChar(20)
  xeroAccountName String          @map("xero_account_name") @db.VarChar(200)
  isActive        Boolean         @default(true) @map("is_active")
  createdAt       DateTime        @default(now()) @map("created_at")
  updatedAt       DateTime        @updatedAt @map("updated_at")

  tenant Tenant @relation(fields: [tenantId], references: [id])

  @@unique([tenantId, accountType])
  @@index([tenantId])
  @@map("xero_account_mappings")
}

model PayrollJournal {
  id               String               @id @default(uuid())
  tenantId         String               @map("tenant_id")
  payrollId        String               @unique @map("payroll_id")
  xeroJournalId    String?              @map("xero_journal_id") @db.VarChar(50)
  journalNumber    String?              @map("journal_number") @db.VarChar(50)
  payPeriodStart   DateTime             @map("pay_period_start") @db.Date
  payPeriodEnd     DateTime             @map("pay_period_end") @db.Date
  status           PayrollJournalStatus @default(PENDING)
  totalDebitCents  Int                  @map("total_debit_cents")
  totalCreditCents Int                  @map("total_credit_cents")
  narration        String               @db.VarChar(500)
  postedAt         DateTime?            @map("posted_at")
  errorMessage     String?              @map("error_message")
  retryCount       Int                  @default(0) @map("retry_count")
  createdAt        DateTime             @default(now()) @map("created_at")
  updatedAt        DateTime             @updatedAt @map("updated_at")

  tenant       Tenant               @relation(fields: [tenantId], references: [id])
  payroll      Payroll              @relation(fields: [payrollId], references: [id])
  journalLines PayrollJournalLine[]

  @@index([tenantId, status])
  @@map("payroll_journals")
}

model PayrollJournalLine {
  id              String          @id @default(uuid())
  journalId       String          @map("journal_id")
  accountType     XeroAccountType @map("account_type")
  xeroAccountCode String          @map("xero_account_code") @db.VarChar(20)
  description     String          @db.VarChar(255)
  debitCents      Int             @default(0) @map("debit_cents")
  creditCents     Int             @default(0) @map("credit_cents")
  sortOrder       Int             @default(0) @map("sort_order")

  journal PayrollJournal @relation(fields: [journalId], references: [id], onDelete: Cascade)

  @@index([journalId])
  @@map("payroll_journal_lines")
}

// ============================================
// TASK-XERO-007: Categorization Journal Model
// For reconciled transactions that can't be edited
// ============================================

model CategorizationJournal {
  id              String                      @id @default(uuid())
  tenantId        String                      @map("tenant_id")
  transactionId   String                      @unique @map("transaction_id")
  xeroJournalId   String?                     @map("xero_journal_id") @db.VarChar(50)
  journalNumber   String?                     @map("journal_number") @db.VarChar(50)
  status          CategorizationJournalStatus @default(PENDING)
  fromAccountCode String                      @map("from_account_code") @db.VarChar(20) // Suspense account (9999)
  toAccountCode   String                      @map("to_account_code") @db.VarChar(20) // Target expense account
  amountCents     Int                         @map("amount_cents")
  isCredit        Boolean                     @map("is_credit")
  narration       String                      @db.VarChar(500)
  postedAt        DateTime?                   @map("posted_at")
  errorMessage    String?                     @map("error_message")
  retryCount      Int                         @default(0) @map("retry_count")
  createdAt       DateTime                    @default(now()) @map("created_at")
  updatedAt       DateTime                    @updatedAt @map("updated_at")

  tenant      Tenant      @relation(fields: [tenantId], references: [id])
  transaction Transaction @relation(fields: [transactionId], references: [id])

  @@index([tenantId, status])
  @@map("categorization_journals")
}

// ============================================
// TASK-STAFF-002: Staff Offboarding Models
// ============================================

model StaffOffboarding {
  id                 String                 @id @default(uuid())
  tenantId           String                 @map("tenant_id")
  staffId            String                 @unique @map("staff_id")
  status             StaffOffboardingStatus @default(INITIATED)
  reason             OffboardingReason
  initiatedAt        DateTime               @default(now()) @map("initiated_at")
  initiatedBy        String?                @map("initiated_by")
  lastWorkingDay     DateTime               @map("last_working_day") @db.Date
  noticePeriodDays   Int                    @map("notice_period_days")
  noticePeriodWaived Boolean                @default(false) @map("notice_period_waived")

  // Final Pay Calculation (all in cents)
  outstandingSalaryCents Int     @default(0) @map("outstanding_salary_cents")
  leavePayoutCents       Int     @default(0) @map("leave_payout_cents")
  leaveBalanceDays       Decimal @default(0) @map("leave_balance_days") @db.Decimal(5, 2)
  noticePayCents         Int     @default(0) @map("notice_pay_cents")
  proRataBonusCents      Int     @default(0) @map("pro_rata_bonus_cents")
  otherEarningsCents     Int     @default(0) @map("other_earnings_cents")
  deductionsCents        Int     @default(0) @map("deductions_cents")
  finalPayGrossCents     Int     @default(0) @map("final_pay_gross_cents")
  finalPayNetCents       Int     @default(0) @map("final_pay_net_cents")

  // Documents Generated
  ui19GeneratedAt        DateTime? @map("ui19_generated_at")
  certificateGeneratedAt DateTime? @map("certificate_generated_at")
  irp5GeneratedAt        DateTime? @map("irp5_generated_at")
  exitPackGeneratedAt    DateTime? @map("exit_pack_generated_at")

  // Exit Interview
  exitInterviewDate      DateTime? @map("exit_interview_date")
  exitInterviewNotes     String?   @map("exit_interview_notes")
  exitInterviewCompleted Boolean   @default(false) @map("exit_interview_completed")

  // Completion
  completedAt DateTime? @map("completed_at")
  completedBy String?   @map("completed_by")
  notes       String?

  // SimplePay Integration (TASK-STAFF-006)
  simplePaySyncStatus String?   @map("simplepay_sync_status") @db.VarChar(20) // PENDING, SUCCESS, FAILED, NOT_APPLICABLE
  simplePaySyncError  String?   @map("simplepay_sync_error")
  simplePaySyncedAt   DateTime? @map("simplepay_synced_at")

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  tenant       Tenant        @relation(fields: [tenantId], references: [id])
  staff        Staff         @relation(fields: [staffId], references: [id])
  assetReturns AssetReturn[]

  @@index([tenantId])
  @@index([tenantId, status])
  @@map("staff_offboardings")
}

model AssetReturn {
  id               String            @id @default(uuid())
  offboardingId    String            @map("offboarding_id")
  assetType        String            @map("asset_type") @db.VarChar(100)
  assetDescription String            @map("asset_description") @db.VarChar(255)
  serialNumber     String?           @map("serial_number") @db.VarChar(100)
  status           AssetReturnStatus @default(PENDING)
  returnedAt       DateTime?         @map("returned_at")
  checkedBy        String?           @map("checked_by")
  notes            String?

  offboarding StaffOffboarding @relation(fields: [offboardingId], references: [id], onDelete: Cascade)

  @@index([offboardingId])
  @@map("asset_returns")
}

// ============================================
// TASK-STAFF-006: UI-19 Deadline Tracking
// ============================================

model UI19Submission {
  id              String     @id @default(uuid())
  tenantId        String     @map("tenant_id")
  staffId         String     @map("staff_id")
  type            UI19Type
  eventDate       DateTime   @map("event_date") @db.Date
  dueDate         DateTime   @map("due_date") @db.Date
  status          UI19Status @default(PENDING)
  submittedAt     DateTime?  @map("submitted_at")
  submittedBy     String?    @map("submitted_by")
  referenceNumber String?    @map("reference_number") @db.VarChar(50)
  lateReason      String?    @map("late_reason") @db.VarChar(500)
  notes           String?
  createdAt       DateTime   @default(now()) @map("created_at")
  updatedAt       DateTime   @updatedAt @map("updated_at")

  tenant Tenant @relation(fields: [tenantId], references: [id])
  staff  Staff  @relation(fields: [staffId], references: [id])

  @@unique([staffId, type, eventDate])
  @@index([tenantId])
  @@index([tenantId, status])
  @@index([dueDate])
  @@map("ui19_submissions")
}

// ============================================
// TASK-STAFF-004: SimplePay Integration
// ============================================

enum SimplePaySyncStatus {
  NOT_SYNCED
  SYNCED
  SYNC_FAILED
  OUT_OF_SYNC
}

model SimplePayConnection {
  id               String    @id @default(uuid())
  tenantId         String    @unique @map("tenant_id")
  clientId         String    @map("client_id") @db.VarChar(50)
  apiKey           String    @map("api_key") @db.VarChar(255)
  isActive         Boolean   @default(true) @map("is_active")
  lastSyncAt       DateTime? @map("last_sync_at")
  syncErrorMessage String?   @map("sync_error_message")
  createdAt        DateTime  @default(now()) @map("created_at")
  updatedAt        DateTime  @updatedAt @map("updated_at")

  tenant Tenant @relation(fields: [tenantId], references: [id])

  @@map("simplepay_connections")
}

model SimplePayEmployeeMapping {
  id                  String              @id @default(uuid())
  tenantId            String              @map("tenant_id")
  staffId             String              @unique @map("staff_id")
  simplePayEmployeeId String              @map("simplepay_employee_id") @db.VarChar(50)
  syncStatus          SimplePaySyncStatus @default(NOT_SYNCED) @map("sync_status")
  lastSyncAt          DateTime?           @map("last_sync_at")
  lastSyncError       String?             @map("last_sync_error")
  createdAt           DateTime            @default(now()) @map("created_at")
  updatedAt           DateTime            @updatedAt @map("updated_at")

  tenant Tenant @relation(fields: [tenantId], references: [id])
  staff  Staff  @relation(fields: [staffId], references: [id], onDelete: Cascade)

  @@index([tenantId])
  @@index([simplePayEmployeeId])
  @@map("simplepay_employee_mappings")
}

model SimplePayPayslipImport {
  id                 String   @id @default(uuid())
  tenantId           String   @map("tenant_id")
  staffId            String   @map("staff_id")
  simplePayPayslipId String   @map("simplepay_payslip_id") @db.VarChar(50)
  payPeriodStart     DateTime @map("pay_period_start") @db.Date
  payPeriodEnd       DateTime @map("pay_period_end") @db.Date
  grossSalaryCents   Int      @map("gross_salary_cents")
  netSalaryCents     Int      @map("net_salary_cents")
  payeCents          Int      @map("paye_cents")
  uifEmployeeCents   Int      @map("uif_employee_cents")
  uifEmployerCents   Int      @map("uif_employer_cents")
  payslipData        Json     @map("payslip_data")
  importedAt         DateTime @default(now()) @map("imported_at")

  tenant Tenant @relation(fields: [tenantId], references: [id])
  staff  Staff  @relation(fields: [staffId], references: [id])

  @@unique([tenantId, staffId, simplePayPayslipId])
  @@index([tenantId, staffId])
  @@map("simplepay_payslip_imports")
}

// ============================================
// TASK-SPAY-001: SimplePay Leave Management
// ============================================

enum LeaveRequestStatus {
  PENDING
  APPROVED
  REJECTED
  CANCELLED
}

model LeaveRequest {
  id              String             @id @default(uuid())
  tenantId        String             @map("tenant_id")
  staffId         String             @map("staff_id")
  leaveTypeId     Int                @map("leave_type_id")
  leaveTypeName   String             @map("leave_type_name") @db.VarChar(100)
  startDate       DateTime           @map("start_date") @db.Date
  endDate         DateTime           @map("end_date") @db.Date
  totalDays       Decimal            @map("total_days") @db.Decimal(4, 1)
  totalHours      Decimal            @map("total_hours") @db.Decimal(5, 1)
  reason          String?
  status          LeaveRequestStatus @default(PENDING)
  approvedBy      String?            @map("approved_by")
  approvedAt      DateTime?          @map("approved_at")
  rejectedReason  String?            @map("rejected_reason")
  simplePaySynced Boolean            @default(false) @map("simplepay_synced")
  simplePayIds    String[]           @map("simplepay_ids")
  createdAt       DateTime           @default(now()) @map("created_at")
  updatedAt       DateTime           @updatedAt @map("updated_at")

  tenant Tenant @relation(fields: [tenantId], references: [id])
  staff  Staff  @relation(fields: [staffId], references: [id], onDelete: Cascade)

  @@index([tenantId])
  @@index([staffId])
  @@index([tenantId, status])
  @@map("leave_requests")
}

// ============================================
// TASK-SPAY-002: Pay Run Tracking
// ============================================

enum PayRunSyncStatus {
  PENDING
  SYNCED
  XERO_POSTED
  XERO_FAILED
}

model PayRunSync {
  id                    String           @id @default(uuid())
  tenantId              String           @map("tenant_id")
  simplePayPayRunId     String           @map("simplepay_payrun_id")
  waveId                Int              @map("wave_id")
  waveName              String           @map("wave_name") @db.VarChar(100)
  periodStart           DateTime         @map("period_start") @db.Date
  periodEnd             DateTime         @map("period_end") @db.Date
  payDate               DateTime         @map("pay_date") @db.Date
  status                String           @default("draft") @db.VarChar(20)
  employeeCount         Int              @map("employee_count")
  totalGrossCents       Int              @map("total_gross_cents")
  totalNetCents         Int              @map("total_net_cents")
  totalPayeCents        Int              @map("total_paye_cents")
  totalUifEmployeeCents Int              @map("total_uif_employee_cents")
  totalUifEmployerCents Int              @map("total_uif_employer_cents")
  totalSdlCents         Int              @map("total_sdl_cents")
  totalEtiCents         Int              @default(0) @map("total_eti_cents")
  syncStatus            PayRunSyncStatus @default(PENDING) @map("sync_status")
  xeroJournalId         String?          @map("xero_journal_id")
  xeroSyncedAt          DateTime?        @map("xero_synced_at")
  xeroSyncError         String?          @map("xero_sync_error") @db.Text
  accountingData        Json?            @map("accounting_data")
  createdAt             DateTime         @default(now()) @map("created_at")
  updatedAt             DateTime         @updatedAt @map("updated_at")

  tenant Tenant @relation(fields: [tenantId], references: [id])

  @@unique([tenantId, simplePayPayRunId])
  @@index([tenantId])
  @@index([tenantId, periodStart])
  @@index([syncStatus])
  @@map("payrun_syncs")
}

// ============================================
// TASK-SPAY-003: SimplePay Calculations Management
// ============================================

enum CalculationType {
  EARNING
  DEDUCTION
  COMPANY_CONTRIBUTION
}

model CalculationItemCache {
  id         String          @id @default(uuid())
  tenantId   String          @map("tenant_id")
  code       String          @db.VarChar(50)
  name       String          @db.VarChar(200)
  type       CalculationType
  taxable    Boolean
  affectsUif Boolean         @map("affects_uif")
  category   String?         @db.VarChar(100)
  cachedAt   DateTime        @default(now()) @map("cached_at")
  updatedAt  DateTime        @updatedAt @map("updated_at")

  tenant Tenant @relation(fields: [tenantId], references: [id])

  @@unique([tenantId, code])
  @@index([tenantId])
  @@index([tenantId, type])
  @@map("calculation_item_cache")
}

model PayrollAdjustment {
  id                String          @id @default(uuid())
  tenantId          String          @map("tenant_id")
  staffId           String          @map("staff_id")
  itemCode          String          @map("item_code") @db.VarChar(50)
  itemName          String          @map("item_name") @db.VarChar(200)
  type              CalculationType
  amountCents       Int?            @map("amount_cents")
  percentage        Decimal?        @db.Decimal(5, 2)
  isRecurring       Boolean         @default(true) @map("is_recurring")
  effectiveDate     DateTime        @map("effective_date") @db.Date
  endDate           DateTime?       @map("end_date") @db.Date
  simplePayCalcId   String?         @map("simplepay_calc_id")
  syncedToSimplePay Boolean         @default(false) @map("synced_to_simplepay")
  createdAt         DateTime        @default(now()) @map("created_at")
  updatedAt         DateTime        @updatedAt @map("updated_at")

  tenant Tenant @relation(fields: [tenantId], references: [id])
  staff  Staff  @relation(fields: [staffId], references: [id], onDelete: Cascade)

  @@index([tenantId])
  @@index([staffId])
  @@index([tenantId, staffId, isRecurring])
  @@map("payroll_adjustments")
}

// ============================================
// TASK-SPAY-004: Service Period Management
// South African UI-19 Termination Codes
// ============================================

enum TerminationCode {
  RESIGNATION // Code 1: UIF eligible after waiting period
  DISMISSAL_MISCONDUCT // Code 2: NOT UIF eligible
  DISMISSAL_INCAPACITY // Code 3: UIF eligible
  RETRENCHMENT // Code 4: UIF eligible
  CONTRACT_EXPIRY // Code 5: UIF eligible
  RETIREMENT // Code 6: UIF eligible
  DEATH // Code 7: Benefits to dependents
  ABSCONDED // Code 8: NOT UIF eligible
  TRANSFER // Code 9: N/A
}

model ServicePeriodSync {
  id                  String           @id @default(uuid())
  tenantId            String           @map("tenant_id")
  staffId             String           @map("staff_id")
  simplePayEmployeeId String           @map("simplepay_employee_id") @db.VarChar(50)
  simplePayPeriodId   String           @map("simplepay_period_id") @db.VarChar(50)
  startDate           DateTime         @map("start_date") @db.Date
  endDate             DateTime?        @map("end_date") @db.Date
  terminationCode     TerminationCode? @map("termination_code")
  terminationReason   String?          @map("termination_reason") @db.Text
  lastWorkingDay      DateTime?        @map("last_working_day") @db.Date
  finalPayslipId      String?          @map("final_payslip_id") @db.VarChar(50)
  isActive            Boolean          @default(true) @map("is_active")
  syncedAt            DateTime         @default(now()) @map("synced_at")
  updatedAt           DateTime         @updatedAt @map("updated_at")

  tenant Tenant @relation(fields: [tenantId], references: [id])
  staff  Staff  @relation(fields: [staffId], references: [id], onDelete: Cascade)

  @@unique([tenantId, staffId, simplePayPeriodId])
  @@index([tenantId])
  @@index([staffId])
  @@index([tenantId, isActive])
  @@map("service_period_syncs")
}

// ============================================
// TASK-SPAY-005: SimplePay Reports Management
// ============================================

enum ReportStatus {
  QUEUED
  PROCESSING
  COMPLETED
  FAILED
}

enum ReportType {
  ETI
  TRANSACTION_HISTORY
  VARIANCE
  LEAVE_COMPARISON
  LEAVE_LIABILITY
  TRACKED_BALANCES
}

model ReportRequest {
  id           String       @id @default(uuid())
  tenantId     String       @map("tenant_id")
  reportType   ReportType   @map("report_type")
  params       Json
  status       ReportStatus @default(QUEUED)
  asyncUuid    String?      @map("async_uuid") @db.VarChar(100)
  resultData   Json?        @map("result_data")
  errorMessage String?      @map("error_message")
  requestedBy  String?      @map("requested_by")
  requestedAt  DateTime     @default(now()) @map("requested_at")
  completedAt  DateTime?    @map("completed_at")
  createdAt    DateTime     @default(now()) @map("created_at")
  updatedAt    DateTime     @updatedAt @map("updated_at")

  tenant Tenant @relation(fields: [tenantId], references: [id])

  @@index([tenantId])
  @@index([status])
  @@index([asyncUuid])
  @@map("report_requests")
}

// ============================================
// TASK-SPAY-006: SimplePay Profile Mapping Sync
// ============================================

model ProfileMappingSync {
  id                  String   @id @default(uuid())
  tenantId            String   @map("tenant_id")
  staffId             String   @map("staff_id")
  simplePayMappingId  Int      @map("simplepay_mapping_id")
  simplePayProfileId  Int      @map("simplepay_profile_id")
  profileName         String   @map("profile_name") @db.VarChar(100)
  calculationSettings Json     @map("calculation_settings")
  syncedAt            DateTime @default(now()) @map("synced_at")
  createdAt           DateTime @default(now()) @map("created_at")
  updatedAt           DateTime @updatedAt @map("updated_at")

  tenant Tenant @relation(fields: [tenantId], references: [id])
  staff  Staff  @relation(fields: [staffId], references: [id], onDelete: Cascade)

  @@unique([tenantId, staffId, simplePayMappingId])
  @@index([tenantId])
  @@index([staffId])
  @@index([simplePayProfileId])
  @@map("profile_mapping_sync")
}

// ============================================
// TASK-SPAY-007: SimplePay Bulk Operations
// ============================================

enum BulkOperationType {
  GENERIC_INPUT
  SALARY_ADJUSTMENT
  BONUS_DISTRIBUTION
  DEDUCTION_SETUP
  EMPLOYEE_UPDATE
}

enum BulkOperationStatus {
  PENDING
  PROCESSING
  COMPLETED
  PARTIAL_FAILURE
  FAILED
}

model BulkOperationLog {
  id            String              @id @default(cuid())
  tenantId      String              @map("tenant_id")
  operationType BulkOperationType   @map("operation_type")
  status        BulkOperationStatus @default(PENDING)
  totalEntities Int                 @map("total_entities")
  successCount  Int                 @default(0) @map("success_count")
  failureCount  Int                 @default(0) @map("failure_count")
  requestData   Json                @map("request_data")
  resultData    Json?               @map("result_data")
  errors        Json?
  warnings      Json?
  executedBy    String              @map("executed_by")
  startedAt     DateTime            @default(now()) @map("started_at")
  completedAt   DateTime?           @map("completed_at")

  tenant Tenant @relation(fields: [tenantId], references: [id])

  @@index([tenantId])
  @@index([operationType])
  @@index([status])
  @@map("bulk_operation_logs")
}

// ============================================
// TASK-SPAY-008: Employee Setup Pipeline
// Auto-setup pipeline for one-click payroll setup
// ============================================

enum SetupStatus {
  PENDING
  IN_PROGRESS
  COMPLETED
  PARTIAL
  FAILED
  ROLLED_BACK
}

// TASK-SARS-002: VAT201 Adjustment Fields (Fields 7-13)
// South African VAT201 form adjustment types per SARS specification
enum VatAdjustmentType {
  CHANGE_IN_USE_OUTPUT // Field 7: Change in use adjustments (Output)
  CHANGE_IN_USE_INPUT // Field 8: Change in use adjustments (Input)
  OTHER_OUTPUT // Field 9: Other adjustments to output tax
  OTHER_INPUT // Field 10: Other adjustments to input tax
  BAD_DEBTS_WRITTEN_OFF // Field 11: Bad debts written off
  BAD_DEBTS_RECOVERED // Field 12: Bad debts recovered
  CAPITAL_GOODS_SCHEME // Field 13: Capital goods scheme adjustments
}

model EmployeeSetupLog {
  id                  String      @id @default(cuid())
  tenantId            String      @map("tenant_id")
  staffId             String      @unique @map("staff_id")
  simplePayEmployeeId String?     @map("simplepay_employee_id")
  status              SetupStatus @default(PENDING)
  setupSteps          Json        @default("[]") @map("setup_steps")
  profileAssigned     String?     @map("profile_assigned")
  leaveInitialized    Boolean     @default(false) @map("leave_initialized")
  taxConfigured       Boolean     @default(false) @map("tax_configured")
  calculationsAdded   Int         @default(0) @map("calculations_added")
  triggeredBy         String      @map("triggered_by")
  errors              Json?
  warnings            Json?
  startedAt           DateTime    @default(now()) @map("started_at")
  completedAt         DateTime?   @map("completed_at")

  tenant Tenant @relation(fields: [tenantId], references: [id])
  staff  Staff  @relation(fields: [staffId], references: [id], onDelete: Cascade)

  @@index([tenantId])
  @@index([status])
  @@map("employee_setup_logs")
}

// ============================================
// TASK-SARS-002: VAT201 Adjustment Fields (7-13)
// Stores VAT adjustments for VAT201 return generation
// ============================================

model VatAdjustment {
  id             String            @id @default(uuid())
  tenantId       String            @map("tenant_id")
  adjustmentType VatAdjustmentType @map("adjustment_type")
  amountCents    Int               @map("amount_cents") // Always positive, sign determined by type
  adjustmentDate DateTime          @map("adjustment_date") @db.Date
  description    String            @db.VarChar(500)
  reference      String?           @db.VarChar(100) // Invoice/transaction reference if applicable
  invoiceId      String?           @map("invoice_id") // Link to invoice for bad debts
  transactionId  String?           @map("transaction_id") // Link to transaction if applicable
  notes          String?           @db.Text
  isVoided       Boolean           @default(false) @map("is_voided")
  voidedAt       DateTime?         @map("voided_at")
  voidedBy       String?           @map("voided_by")
  voidReason     String?           @map("void_reason") @db.Text
  createdBy      String            @map("created_by")
  createdAt      DateTime          @default(now()) @map("created_at")
  updatedAt      DateTime          @updatedAt @map("updated_at")

  tenant Tenant @relation(fields: [tenantId], references: [id])

  @@index([tenantId])
  @@index([tenantId, adjustmentType])
  @@index([tenantId, adjustmentDate])
  @@index([tenantId, isVoided])
  @@map("vat_adjustments")
}

// ============================================
// TASK-SPAY-009: SimplePay Webhook Handler
// Logs incoming webhooks for audit and processing
// ============================================

model WebhookLog {
  id          String    @id @default(uuid())
  tenantId    String?   @map("tenant_id")
  source      String    @db.VarChar(50)
  eventType   String    @map("event_type") @db.VarChar(100)
  deliveryId  String?   @map("delivery_id") @db.VarChar(100) // SimplePay delivery_id for idempotency
  payload     Json
  processed   Boolean   @default(false)
  processedAt DateTime? @map("processed_at")
  error       String?   @db.Text
  createdAt   DateTime  @default(now()) @map("created_at")

  tenant Tenant? @relation(fields: [tenantId], references: [id])

  @@unique([source, deliveryId]) // Ensure idempotency per source
  @@index([source, eventType])
  @@index([processed])
  @@index([createdAt])
  @@map("webhook_logs")
}

// ============================================
// TASK-XERO-009: Bidirectional Invoice Sync
// Track invoice sync mapping between CrecheBooks and Xero
// ============================================

enum InvoiceSyncDirection {
  PUSH // CrecheBooks -> Xero
  PULL // Xero -> CrecheBooks
  BIDIRECTIONAL
}

enum InvoiceSyncStatus {
  SYNCED
  PENDING
  FAILED
  OUT_OF_SYNC
}

model XeroInvoiceMapping {
  id                String               @id @default(uuid())
  tenantId          String               @map("tenant_id")
  invoiceId         String               @unique @map("invoice_id")
  xeroInvoiceId     String               @map("xero_invoice_id") @db.VarChar(50)
  xeroInvoiceNumber String?              @map("xero_invoice_number") @db.VarChar(50)
  lastSyncedAt      DateTime             @map("last_synced_at")
  syncDirection     InvoiceSyncDirection @map("sync_direction")
  syncStatus        InvoiceSyncStatus    @default(SYNCED) @map("sync_status")
  syncErrorMessage  String?              @map("sync_error_message")
  createdAt         DateTime             @default(now()) @map("created_at")
  updatedAt         DateTime             @updatedAt @map("updated_at")

  tenant  Tenant  @relation(fields: [tenantId], references: [id])
  invoice Invoice @relation(fields: [invoiceId], references: [id])

  @@unique([tenantId, invoiceId])
  @@unique([tenantId, xeroInvoiceId])
  @@index([tenantId])
  @@index([tenantId, syncStatus])
  @@map("xero_invoice_mappings")
}

// ============================================
// TASK-XERO-010: Xero Contact and Payment Sync
// Maps parent records to Xero contacts for invoice/payment sync
// ============================================

model XeroContactMapping {
  id              String   @id @default(uuid())
  tenantId        String   @map("tenant_id")
  parentId        String   @unique @map("parent_id")
  xeroContactId   String   @map("xero_contact_id")
  xeroContactName String?  @map("xero_contact_name")
  lastSyncedAt    DateTime @map("last_synced_at")
  createdAt       DateTime @default(now()) @map("created_at")
  updatedAt       DateTime @updatedAt @map("updated_at")

  tenant Tenant @relation(fields: [tenantId], references: [id])
  parent Parent @relation(fields: [parentId], references: [id])

  @@unique([tenantId, parentId])
  @@unique([tenantId, xeroContactId])
  @@index([tenantId])
  @@map("xero_contact_mappings")
}

// ============================================
// TASK-XERO-010: Xero Payment Mapping
// Tracks payments synced between CrecheBooks and Xero
// ============================================

model XeroPaymentMapping {
  id            String   @id @default(uuid())
  tenantId      String   @map("tenant_id")
  paymentId     String   @unique @map("payment_id")
  xeroPaymentId String   @map("xero_payment_id")
  xeroInvoiceId String   @map("xero_invoice_id")
  amountCents   Int      @map("amount_cents")
  syncDirection String   @map("sync_direction") // 'push' or 'pull'
  lastSyncedAt  DateTime @map("last_synced_at")
  createdAt     DateTime @default(now()) @map("created_at")
  updatedAt     DateTime @updatedAt @map("updated_at")

  tenant  Tenant  @relation(fields: [tenantId], references: [id])
  payment Payment @relation(fields: [paymentId], references: [id])

  @@unique([tenantId, paymentId])
  @@unique([tenantId, xeroPaymentId])
  @@index([tenantId])
  @@index([tenantId, xeroInvoiceId])
  @@map("xero_payment_mappings")
}

// ============================================
// TASK-RECON-036: Accrued Bank Charges
// Tracks bank fees shown on statements but charged in following period
// FNB shows fees next to transactions but charges them in the next billing cycle
// ============================================

model AccruedBankCharge {
  id       String @id @default(uuid())
  tenantId String @map("tenant_id")

  // Source transaction that attracted the fee (e.g., ADT Cash Deposit)
  sourceTransactionId String?  @map("source_transaction_id")
  sourceDescription   String   @map("source_description")
  sourceDate          DateTime @map("source_date") @db.Date
  sourceAmountCents   Int      @map("source_amount_cents") // NET amount credited

  // The fee details
  accruedAmountCents Int                     @map("accrued_amount_cents") // Fee amount
  feeType            String                  @map("fee_type") @db.VarChar(50) // ADT_DEPOSIT_FEE, CASH_DEPOSIT_FEE, etc.
  feeDescription     String?                 @map("fee_description")
  status             AccruedBankChargeStatus @default(ACCRUED)

  // Link to the bank statement match where this fee was detected
  bankStatementMatchId String? @unique @map("bank_statement_match_id")

  // Link to Xero transaction (has GROSS amount including fee)
  xeroTransactionId String? @map("xero_transaction_id")
  xeroAmountCents   Int?    @map("xero_amount_cents") // GROSS amount from Xero

  // When the fee is actually charged (matched to a real bank transaction)
  chargeTransactionId String?   @map("charge_transaction_id")
  chargeDate          DateTime? @map("charge_date") @db.Date
  matchedAt           DateTime? @map("matched_at")
  matchedBy           String?   @map("matched_by")

  // Metadata
  notes     String?  @db.Text
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  // Relations
  tenant             Tenant              @relation(fields: [tenantId], references: [id])
  sourceTransaction  Transaction?        @relation("AccruedChargeSource", fields: [sourceTransactionId], references: [id], onDelete: SetNull)
  chargeTransaction  Transaction?        @relation("AccruedChargeActual", fields: [chargeTransactionId], references: [id], onDelete: SetNull)
  bankStatementMatch BankStatementMatch? @relation(fields: [bankStatementMatchId], references: [id], onDelete: SetNull)
  matcher            User?               @relation("AccruedChargeMatcher", fields: [matchedBy], references: [id], onDelete: SetNull)

  // TASK-RECON-037: Link to Xero transaction split
  xeroTransactionSplit XeroTransactionSplit?

  @@index([tenantId])
  @@index([tenantId, status])
  @@index([tenantId, feeType])
  @@index([sourceDate])
  @@index([chargeTransactionId])
  @@map("accrued_bank_charges")
}

// TASK-RECON-037: Xero Transaction Splitting
// Splits a Xero transaction (gross) into net amount + fee for bank statement matching
model XeroTransactionSplit {
  id       String @id @default(uuid())
  tenantId String @map("tenant_id")

  // Original Xero transaction (gross amount)
  xeroTransactionId   String @map("xero_transaction_id") // Xero transaction ID
  originalAmountCents Int    @map("original_amount_cents") // GROSS amount from Xero

  // Split amounts
  netAmountCents Int @map("net_amount_cents") // Amount matching bank statement
  feeAmountCents Int @map("fee_amount_cents") // Bank fee portion

  // Fee details
  feeType        String  @map("fee_type") @db.VarChar(50) // ADT_DEPOSIT_FEE, etc.
  feeDescription String? @map("fee_description")

  // Status
  status XeroTransactionSplitStatus @default(PENDING)

  // Link to accrued bank charge (created for the fee portion)
  accruedChargeId String? @unique @map("accrued_charge_id")

  // Bank matching - where the net amount will be matched
  bankTransactionId    String? @map("bank_transaction_id")
  bankStatementMatchId String? @map("bank_statement_match_id")

  // Metadata
  notes       String?   @db.Text
  createdBy   String?   @map("created_by")
  confirmedBy String?   @map("confirmed_by")
  confirmedAt DateTime? @map("confirmed_at")
  createdAt   DateTime  @default(now()) @map("created_at")
  updatedAt   DateTime  @updatedAt @map("updated_at")

  // Relations
  tenant             Tenant              @relation(fields: [tenantId], references: [id])
  accruedCharge      AccruedBankCharge?  @relation(fields: [accruedChargeId], references: [id], onDelete: SetNull)
  bankTransaction    Transaction?        @relation("XeroSplitBankTransaction", fields: [bankTransactionId], references: [id], onDelete: SetNull)
  bankStatementMatch BankStatementMatch? @relation(fields: [bankStatementMatchId], references: [id], onDelete: SetNull)
  creator            User?               @relation("XeroSplitCreator", fields: [createdBy], references: [id], onDelete: SetNull)
  confirmer          User?               @relation("XeroSplitConfirmer", fields: [confirmedBy], references: [id], onDelete: SetNull)

  @@index([tenantId])
  @@index([tenantId, status])
  @@index([xeroTransactionId])
  @@index([bankTransactionId])
  @@map("xero_transaction_splits")
}

// ============================================
// TASK-REL-101: Circuit Breaker Pending Sync Queue
// Database-backed queue for entities that failed to sync to Xero
// when circuit breaker is open. Persists across restarts.
// ============================================

enum PendingSyncStatus {
  PENDING // Queued for sync
  PROCESSING // Currently being processed
  COMPLETED // Successfully synced
  FAILED // Max attempts reached
  RETRY // Failed but can retry
}

enum PendingSyncEntityType {
  INVOICE
  PAYMENT
  TRANSACTION
  CONTACT
  JOURNAL
}

// ============================================
// TASK-WA-001: WhatsApp Message History
// ============================================

enum WhatsAppMessageStatus {
  PENDING
  SENT
  DELIVERED
  READ
  FAILED
}

enum WhatsAppContextType {
  INVOICE
  REMINDER
  STATEMENT
  WELCOME
  ARREARS
}

model PendingSync {
  id          String                @id @default(cuid())
  tenantId    String                @map("tenant_id")
  entityType  PendingSyncEntityType @map("entity_type")
  entityId    String                @map("entity_id")
  operation   String                @db.VarChar(20) // create, update, delete
  payload     Json? // Serialized entity data for retry
  status      PendingSyncStatus     @default(PENDING)
  attempts    Int                   @default(0)
  maxAttempts Int                   @default(3) @map("max_attempts")
  lastError   String?               @map("last_error") @db.Text
  createdAt   DateTime              @default(now()) @map("created_at")
  updatedAt   DateTime              @updatedAt @map("updated_at")
  processedAt DateTime?             @map("processed_at")

  tenant Tenant @relation(fields: [tenantId], references: [id])

  @@index([tenantId, status])
  @@index([entityType, entityId])
  @@index([createdAt])
  @@map("pending_syncs")
}

// ============================================
// TASK-WA-001: WhatsApp Message History Entity
// Tracks all outbound WhatsApp messages for audit trail and POPIA compliance
// ============================================

model WhatsAppMessage {
  id             String  @id @default(uuid())
  tenantId       String  @map("tenant_id")
  parentId       String? @map("parent_id")
  recipientPhone String  @map("recipient_phone") @db.VarChar(20)
  templateName   String  @map("template_name") @db.VarChar(100)
  templateParams Json?   @map("template_params")

  // Message identifiers from Meta
  wamid String? @unique @map("wamid") @db.VarChar(100) // WhatsApp Message ID

  // Status tracking
  status          WhatsAppMessageStatus @default(PENDING)
  statusUpdatedAt DateTime?             @map("status_updated_at")
  errorCode       String?               @map("error_code") @db.VarChar(50)
  errorMessage    String?               @map("error_message") @db.Text

  // Context - links to invoices, statements, etc.
  contextType WhatsAppContextType @map("context_type")
  contextId   String?             @map("context_id") @db.VarChar(100)

  // Timestamps
  sentAt      DateTime? @map("sent_at")
  deliveredAt DateTime? @map("delivered_at")
  readAt      DateTime? @map("read_at")
  createdAt   DateTime  @default(now()) @map("created_at")
  updatedAt   DateTime  @updatedAt @map("updated_at")

  // Relations
  tenant Tenant  @relation(fields: [tenantId], references: [id])
  parent Parent? @relation(fields: [parentId], references: [id])

  @@index([tenantId, parentId])
  @@index([tenantId, status])
  @@index([tenantId, contextType, contextId])
  @@index([wamid])
  @@map("whatsapp_messages")
}

// ============================================
// TASK-COMM-001: Ad-hoc Communication Database Schema
// Broadcast messaging to parents and staff via email, WhatsApp, SMS
// ============================================

model BroadcastMessage {
  id       String @id @default(uuid())
  tenantId String @map("tenant_id")

  // Message content
  subject  String? @db.VarChar(200) // For email
  body     String  @db.Text // Plain text content
  htmlBody String? @map("html_body") @db.Text // HTML for email

  // Targeting
  recipientType    String  @map("recipient_type") @db.VarChar(20) // parent, staff, custom
  recipientFilter  Json?   @map("recipient_filter") // Filter criteria
  recipientGroupId String? @map("recipient_group_id") // Saved group

  // Channel selection
  channel String @db.VarChar(20) // email, whatsapp, sms, all

  // Scheduling
  scheduledAt DateTime? @map("scheduled_at")
  sentAt      DateTime? @map("sent_at")

  // Status
  status          String @default("draft") @db.VarChar(20) // draft, scheduled, sending, sent, partially_sent, failed, cancelled
  totalRecipients Int    @default(0) @map("total_recipients")
  sentCount       Int    @default(0) @map("sent_count")
  failedCount     Int    @default(0) @map("failed_count")

  // Metadata
  createdBy String   @map("created_by") // User ID
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  // Relations
  tenant         Tenant             @relation(fields: [tenantId], references: [id])
  createdByUser  User               @relation("BroadcastMessageCreatedBy", fields: [createdBy], references: [id])
  recipientGroup RecipientGroup?    @relation(fields: [recipientGroupId], references: [id])
  recipients     MessageRecipient[]

  @@index([tenantId, status])
  @@index([tenantId, recipientType])
  @@index([tenantId, createdAt])
  @@map("broadcast_messages")
}

model MessageRecipient {
  id          String @id @default(uuid())
  broadcastId String @map("broadcast_id")

  // Recipient info (copied for audit)
  recipientId    String  @map("recipient_id") // Parent or Staff ID
  recipientType  String  @map("recipient_type") @db.VarChar(20) // parent, staff
  recipientName  String  @map("recipient_name") @db.VarChar(200)
  recipientEmail String? @map("recipient_email") @db.VarChar(255)
  recipientPhone String? @map("recipient_phone") @db.VarChar(20)

  // Delivery status per channel
  emailStatus    String?   @map("email_status") @db.VarChar(20) // pending, sent, delivered, opened, failed, bounced
  emailSentAt    DateTime? @map("email_sent_at")
  emailMessageId String?   @map("email_message_id") @db.VarChar(255) // Mailgun ID

  whatsappStatus String?   @map("whatsapp_status") @db.VarChar(20) // pending, sent, delivered, read, failed
  whatsappSentAt DateTime? @map("whatsapp_sent_at")
  whatsappWamid  String?   @map("whatsapp_wamid") @db.VarChar(100) // WhatsApp Message ID

  smsStatus    String?   @map("sms_status") @db.VarChar(20) // pending, sent, delivered, failed
  smsSentAt    DateTime? @map("sms_sent_at")
  smsMessageId String?   @map("sms_message_id") @db.VarChar(255)

  // Error tracking
  lastError  String? @map("last_error") @db.Text
  retryCount Int     @default(0) @map("retry_count")

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  // Relations
  broadcast BroadcastMessage @relation(fields: [broadcastId], references: [id], onDelete: Cascade)

  @@unique([broadcastId, recipientId])
  @@index([broadcastId, recipientType])
  @@index([emailStatus])
  @@index([whatsappStatus])
  @@map("message_recipients")
}

model RecipientGroup {
  id       String @id @default(uuid())
  tenantId String @map("tenant_id")

  name        String  @db.VarChar(100) // "All Active Parents", "Grade 1 Parents"
  description String? @db.VarChar(500)

  // Filter criteria (stored as JSON)
  recipientType  String @map("recipient_type") @db.VarChar(20) // parent, staff
  filterCriteria Json?  @map("filter_criteria")

  // Metadata
  isSystem  Boolean  @default(false) @map("is_system") // Built-in groups
  createdBy String?  @map("created_by")
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  // Relations
  tenant     Tenant             @relation(fields: [tenantId], references: [id])
  broadcasts BroadcastMessage[]

  @@unique([tenantId, name])
  @@index([tenantId, recipientType])
  @@map("recipient_groups")
}

enum FormSubmissionStatus {
  PENDING
  CONTACTED
  COMPLETED
  SPAM
}

// ============================================
// PUBLIC FORM SUBMISSIONS
// ============================================
model ContactSubmission {
  id        String               @id @default(uuid())
  name      String               @db.VarChar(100)
  email     String               @db.VarChar(255)
  phone     String?              @db.VarChar(20)
  subject   String               @db.VarChar(200)
  message   String               @db.Text
  status    FormSubmissionStatus @default(PENDING)
  createdAt DateTime             @default(now()) @map("created_at")
  updatedAt DateTime             @updatedAt @map("updated_at")

  @@index([email])
  @@index([createdAt])
  @@index([status])
  @@map("contact_submissions")
}

model DemoRequest {
  id               String               @id @default(uuid())
  fullName         String               @map("full_name") @db.VarChar(100)
  email            String               @db.VarChar(255)
  phone            String               @db.VarChar(20)
  crecheName       String               @map("creche_name") @db.VarChar(200)
  childrenCount    Int                  @map("children_count")
  province         String               @db.VarChar(50)
  currentSoftware  String?              @map("current_software") @db.VarChar(200)
  challenges       String[]
  preferredTime    String?              @map("preferred_time") @db.VarChar(20)
  marketingConsent Boolean              @default(false) @map("marketing_consent")
  status           FormSubmissionStatus @default(PENDING)
  createdAt        DateTime             @default(now()) @map("created_at")
  updatedAt        DateTime             @updatedAt @map("updated_at")

  @@index([email])
  @@index([createdAt])
  @@index([status])
  @@index([province])
  @@map("demo_requests")
}

// ============================================
// TASK-ACCT-001: Chart of Accounts
// ============================================
model ChartOfAccount {
  id          String          @id @default(uuid())
  tenantId    String          @map("tenant_id")
  code        String          @db.VarChar(20)
  name        String          @db.VarChar(200)
  type        AccountType
  subType     AccountSubType?
  description String?         @db.Text
  parentId    String?         @map("parent_id")

  // SA Tax Compliance - VAT Section 12(h) education services
  isEducationExempt Boolean @default(false) @map("is_education_exempt")

  // System flags
  isSystem Boolean @default(false) @map("is_system")
  isActive Boolean @default(true) @map("is_active")

  // Xero integration
  xeroAccountId String? @map("xero_account_id") @db.VarChar(50)

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  tenant   Tenant           @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  parent   ChartOfAccount?  @relation("AccountHierarchy", fields: [parentId], references: [id])
  children ChartOfAccount[] @relation("AccountHierarchy")

  openingBalances   OpeningBalance[]
  supplierDefaults  Supplier[]         @relation("SupplierDefaultAccount")
  supplierBillLines SupplierBillLine[]
  quoteLines        QuoteLine[]

  @@unique([tenantId, code])
  @@index([tenantId, type])
  @@index([tenantId, isActive])
  @@map("chart_of_accounts")
}

// ============================================
// TASK-ACCT-003: Opening Balances
// ============================================
model OpeningBalance {
  id           String    @id @default(uuid())
  tenantId     String    @map("tenant_id")
  accountId    String    @map("account_id")
  importId     String?   @map("import_id")
  asOfDate     DateTime  @map("as_of_date") @db.Date
  debitCents   Int?      @map("debit_cents")
  creditCents  Int?      @map("credit_cents")
  notes        String?   @db.Text
  isVerified   Boolean   @default(false) @map("is_verified")
  verifiedById String?   @map("verified_by_id")
  verifiedAt   DateTime? @map("verified_at")

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  tenant     Tenant                @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  account    ChartOfAccount        @relation(fields: [accountId], references: [id])
  import     OpeningBalanceImport? @relation(fields: [importId], references: [id])
  verifiedBy User?                 @relation(fields: [verifiedById], references: [id])

  @@unique([tenantId, accountId, asOfDate])
  @@index([tenantId, asOfDate])
  @@map("opening_balances")
}

model OpeningBalanceImport {
  id            String                     @id @default(uuid())
  tenantId      String                     @map("tenant_id")
  asOfDate      DateTime                   @map("as_of_date") @db.Date
  status        OpeningBalanceImportStatus @default(DRAFT)
  sourceType    String?                    @map("source_type") @db.VarChar(50)
  totalDebits   Int                        @default(0) @map("total_debits")
  totalCredits  Int                        @default(0) @map("total_credits")
  discrepancy   Int                        @default(0)
  errorMessage  String?                    @map("error_message") @db.Text
  processedAt   DateTime?                  @map("processed_at")
  processedById String?                    @map("processed_by_id")

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  tenant          Tenant           @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  processedBy     User?            @relation(fields: [processedById], references: [id])
  openingBalances OpeningBalance[]

  @@index([tenantId, status])
  @@map("opening_balance_imports")
}

// ============================================
// TASK-ACCT-012: Quotes System
// ============================================
model Quote {
  id          String @id @default(uuid())
  tenantId    String @map("tenant_id")
  quoteNumber String @map("quote_number") @db.VarChar(20)

  // Recipient (may not be a Parent yet)
  parentId       String? @map("parent_id")
  recipientName  String  @map("recipient_name") @db.VarChar(200)
  recipientEmail String  @map("recipient_email") @db.VarChar(255)
  recipientPhone String? @map("recipient_phone") @db.VarChar(20)

  // Child info (for enrollment quotes)
  childName         String?   @map("child_name") @db.VarChar(100)
  childDob          DateTime? @map("child_dob") @db.Date
  expectedStartDate DateTime? @map("expected_start_date") @db.Date

  // Dates
  quoteDate    DateTime @default(now()) @map("quote_date")
  expiryDate   DateTime @map("expiry_date")
  validityDays Int      @default(30) @map("validity_days")

  // Amounts
  subtotalCents  Int @map("subtotal_cents")
  vatAmountCents Int @default(0) @map("vat_amount_cents")
  totalCents     Int @map("total_cents")

  // Status
  status        QuoteStatus @default(DRAFT)
  sentAt        DateTime?   @map("sent_at")
  viewedAt      DateTime?   @map("viewed_at")
  acceptedAt    DateTime?   @map("accepted_at")
  declinedAt    DateTime?   @map("declined_at")
  declineReason String?     @map("decline_reason") @db.Text

  // Conversion
  convertedToInvoiceId String?   @map("converted_to_invoice_id")
  convertedAt          DateTime? @map("converted_at")

  // Content
  notes String? @db.Text

  // Audit
  createdById String   @map("created_by_id")
  createdAt   DateTime @default(now()) @map("created_at")
  updatedAt   DateTime @updatedAt @map("updated_at")

  tenant           Tenant      @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  parent           Parent?     @relation(fields: [parentId], references: [id])
  convertedInvoice Invoice?    @relation(fields: [convertedToInvoiceId], references: [id])
  createdBy        User        @relation(fields: [createdById], references: [id])
  lines            QuoteLine[]

  @@unique([tenantId, quoteNumber])
  @@index([tenantId, status])
  @@index([recipientEmail])
  @@map("quotes")
}

model QuoteLine {
  id             String  @id @default(uuid())
  quoteId        String  @map("quote_id")
  lineNumber     Int     @map("line_number")
  description    String  @db.VarChar(500)
  quantity       Int     @default(1)
  unitPriceCents Int     @map("unit_price_cents")
  lineTotalCents Int     @map("line_total_cents")
  vatType        VatType @default(EXEMPT) @map("vat_type")

  // Link to fee structure (optional)
  feeStructureId String?   @map("fee_structure_id")
  lineType       LineType? @map("line_type")

  // Account coding
  accountId String? @map("account_id")

  quote        Quote           @relation(fields: [quoteId], references: [id], onDelete: Cascade)
  feeStructure FeeStructure?   @relation(fields: [feeStructureId], references: [id])
  account      ChartOfAccount? @relation(fields: [accountId], references: [id])

  @@index([quoteId])
  @@map("quote_lines")
}

model QuoteNumberCounter {
  id         String @id @default(uuid())
  tenantId   String @map("tenant_id")
  year       Int
  lastNumber Int    @default(0) @map("last_number")

  tenant Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  @@unique([tenantId, year])
  @@map("quote_number_counters")
}

// ============================================
// TASK-ACCT-013: Supplier Management
// ============================================
model Supplier {
  id                 String  @id @default(uuid())
  tenantId           String  @map("tenant_id")
  name               String  @db.VarChar(200)
  tradingName        String? @map("trading_name") @db.VarChar(200)
  email              String? @db.VarChar(255)
  phone              String? @db.VarChar(20)
  address            String? @db.Text
  vatNumber          String? @map("vat_number") @db.VarChar(20)
  registrationNumber String? @map("registration_number") @db.VarChar(50)
  paymentTermsDays   Int     @default(30) @map("payment_terms_days")

  // Bank details for EFT payments
  bankName      String? @map("bank_name") @db.VarChar(100)
  branchCode    String? @map("branch_code") @db.VarChar(20)
  accountNumber String? @map("account_number") @db.VarChar(50)
  accountType   String? @map("account_type") @db.VarChar(30)

  // Default expense account for categorization
  defaultAccountId String? @map("default_account_id")

  // Status
  isActive Boolean @default(true) @map("is_active")

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  tenant         Tenant          @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  defaultAccount ChartOfAccount? @relation("SupplierDefaultAccount", fields: [defaultAccountId], references: [id])
  bills          SupplierBill[]
  transactions   Transaction[]

  @@unique([tenantId, name])
  @@index([tenantId, isActive])
  @@map("suppliers")
}

model SupplierBill {
  id         String   @id @default(uuid())
  tenantId   String   @map("tenant_id")
  supplierId String   @map("supplier_id")
  billNumber String   @map("bill_number") @db.VarChar(50)
  billDate   DateTime @map("bill_date") @db.Date
  dueDate    DateTime @map("due_date") @db.Date

  // Amounts
  subtotalCents   Int @map("subtotal_cents")
  vatAmountCents  Int @default(0) @map("vat_amount_cents")
  totalCents      Int @map("total_cents")
  paidCents       Int @default(0) @map("paid_cents")
  balanceDueCents Int @map("balance_due_cents")

  // Status
  status   BillStatus @default(DRAFT)
  paidDate DateTime?  @map("paid_date") @db.Date

  // Reference
  purchaseOrderRef String? @map("purchase_order_ref") @db.VarChar(50)
  notes            String? @db.Text

  // Attachments
  attachmentUrl String? @map("attachment_url") @db.VarChar(500)

  // Audit
  createdById String   @map("created_by_id")
  createdAt   DateTime @default(now()) @map("created_at")
  updatedAt   DateTime @updatedAt @map("updated_at")

  tenant    Tenant                @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  supplier  Supplier              @relation(fields: [supplierId], references: [id])
  createdBy User                  @relation(fields: [createdById], references: [id])
  lines     SupplierBillLine[]
  payments  SupplierBillPayment[]

  @@unique([tenantId, supplierId, billNumber])
  @@index([tenantId, status])
  @@index([tenantId, dueDate])
  @@index([supplierId])
  @@map("supplier_bills")
}

model SupplierBillLine {
  id             String  @id @default(uuid())
  billId         String  @map("bill_id")
  lineNumber     Int     @map("line_number")
  description    String  @db.VarChar(500)
  quantity       Decimal @default(1) @db.Decimal(10, 2)
  unitPriceCents Int     @map("unit_price_cents")
  lineTotalCents Int     @map("line_total_cents")
  vatType        VatType @default(STANDARD) @map("vat_type")

  // Account coding
  accountId String? @map("account_id")

  bill    SupplierBill    @relation(fields: [billId], references: [id], onDelete: Cascade)
  account ChartOfAccount? @relation(fields: [accountId], references: [id])

  @@index([billId])
  @@map("supplier_bill_lines")
}

model SupplierBillPayment {
  id            String   @id @default(uuid())
  tenantId      String   @map("tenant_id")
  billId        String   @map("bill_id")
  transactionId String?  @map("transaction_id")
  amountCents   Int      @map("amount_cents")
  paymentDate   DateTime @map("payment_date") @db.Date
  paymentMethod String   @map("payment_method") @db.VarChar(30)
  reference     String?  @db.VarChar(100)

  createdAt DateTime @default(now()) @map("created_at")

  tenant      Tenant       @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  bill        SupplierBill @relation(fields: [billId], references: [id])
  transaction Transaction? @relation(fields: [transactionId], references: [id])

  @@index([billId])
  @@index([transactionId])
  @@map("supplier_bill_payments")
}

// ============================================
// TASK-ACCT-011: Payment Gateway (Yoco)
// ============================================
model PaymentLink {
  id          String            @id @default(uuid())
  tenantId    String            @map("tenant_id")
  parentId    String            @map("parent_id")
  invoiceId   String?           @map("invoice_id")
  type        PaymentLinkType   @default(INVOICE)
  amountCents Int               @map("amount_cents")
  shortCode   String            @unique @map("short_code") @db.VarChar(20)
  description String?           @db.VarChar(200)
  status      PaymentLinkStatus @default(ACTIVE)
  expiresAt   DateTime?         @map("expires_at")

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  tenant              Tenant                      @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  parent              Parent                      @relation(fields: [parentId], references: [id])
  invoice             Invoice?                    @relation(fields: [invoiceId], references: [id])
  gatewayTransactions PaymentGatewayTransaction[]

  @@index([tenantId, status])
  @@index([shortCode])
  @@map("payment_links")
}

model PaymentGatewayTransaction {
  id            String  @id @default(uuid())
  tenantId      String  @map("tenant_id")
  paymentLinkId String? @map("payment_link_id")
  parentId      String  @map("parent_id")
  invoiceId     String? @map("invoice_id")

  // Gateway details
  gateway           String               @db.VarChar(30)
  gatewayId         String               @map("gateway_id") @db.VarChar(100)
  gatewayCheckoutId String?              @map("gateway_checkout_id") @db.VarChar(100)
  status            PaymentGatewayStatus @default(PENDING)

  // Amounts
  amountCents    Int  @map("amount_cents")
  feeCents       Int? @map("fee_cents")
  netAmountCents Int? @map("net_amount_cents")

  // Card details (masked)
  cardBrand       String? @map("card_brand") @db.VarChar(20)
  cardLastFour    String? @map("card_last_four") @db.VarChar(4)
  cardExpiryMonth Int?    @map("card_expiry_month")
  cardExpiryYear  Int?    @map("card_expiry_year")

  // Payment record
  paymentId String? @map("payment_id")

  // Metadata
  metadata     Json?
  errorMessage String? @map("error_message") @db.Text

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  tenant      Tenant       @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  paymentLink PaymentLink? @relation(fields: [paymentLinkId], references: [id])
  parent      Parent       @relation(fields: [parentId], references: [id])
  invoice     Invoice?     @relation(fields: [invoiceId], references: [id])
  payment     Payment?     @relation(fields: [paymentId], references: [id])

  @@unique([gateway, gatewayId])
  @@index([tenantId, status])
  @@index([paymentLinkId])
  @@map("payment_gateway_transactions")
}

// ============================================
// TASK-ACCT-014: Tenant Onboarding Wizard
// ============================================
model OnboardingProgress {
  id       String @id @default(uuid())
  tenantId String @unique @map("tenant_id")

  // Step completion tracking
  logoUploaded        Boolean @default(false) @map("logo_uploaded")
  addressSet          Boolean @default(false) @map("address_set")
  bankDetailsSet      Boolean @default(false) @map("bank_details_set")
  vatConfigured       Boolean @default(false) @map("vat_configured")
  feeStructureCreated Boolean @default(false) @map("fee_structure_created")
  childEnrolled       Boolean @default(false) @map("child_enrolled")
  firstInvoiceSent    Boolean @default(false) @map("first_invoice_sent")
  bankConnected       Boolean @default(false) @map("bank_connected")

  // Skipped steps
  skippedSteps String[] @default([]) @map("skipped_steps")

  // Completion
  completedAt    DateTime? @map("completed_at")
  lastActiveStep String?   @map("last_active_step") @db.VarChar(50)

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  tenant Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  @@map("onboarding_progress")
}
